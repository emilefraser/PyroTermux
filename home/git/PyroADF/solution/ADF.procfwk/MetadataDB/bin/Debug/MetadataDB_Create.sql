/*
Deployment script for MetadataDB

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "MetadataDB"
:setvar DefaultFilePrefix "MetadataDB"
:setvar DefaultDataPath "D:\Database\localdb\MetadataDB"
:setvar DefaultLogPath "D:\Database\localdb\MetadataDB"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
/* Please run the below section of statements against 'master' database. */
PRINT N'Creating $(DatabaseName)...'
GO
DROP DATABASE IF EXISTS [$(DatabaseName)] 
GO
CREATE DATABASE [$(DatabaseName)] COLLATE SQL_Latin1_General_CP1_CI_AS
GO
DECLARE  @job_state INT = 0;
DECLARE  @index INT = 0;
DECLARE @EscapedDBNameLiteral sysname = N'$(DatabaseName)'
WAITFOR DELAY '00:00:01';
--WHILE (@index < 60) 
--BEGIN
--	SET @job_state = ISNULL( (SELECT SUM (result)  FROM (
--		SELECT TOP 1 [state] AS result
--		FROM sys.dm_operation_status WHERE resource_type = 0 
--		AND operation = 'CREATE DATABASE' AND major_resource_id = @EscapedDBNameLiteral AND [state] = 2
--		ORDER BY start_time DESC
--		) r), -1);

--	SET @index = @index + 1;

--	IF @job_state = 0 /* pending */ OR @job_state = 1 /* in progress */ OR @job_state = -1 /* job not found */ OR (SELECT [state] FROM sys.databases WHERE name = @EscapedDBNameLiteral) <> 0
--		WAITFOR DELAY '00:00:01';
--	ELSE 
--    	BREAK;
--END
--GO
/* Please run the below section of statements against the database name that the above [$(DatabaseName)] variable is assigned to. */
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                DATE_CORRELATION_OPTIMIZATION OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
USE [$(DatabaseName)] 
GO

--data
IF OBJECT_ID(N'[dbo].[ExecutionLogBackup]') IS NOT NULL DROP TABLE [dbo].[ExecutionLogBackup];

IF OBJECT_ID(N'[procfwk].[ExecutionLog]') IS NOT NULL --check for new deployments
BEGIN
	SELECT 
		*
	INTO
		[dbo].[ExecutionLogBackup]
	FROM
		[procfwk].[ExecutionLog];
END;
IF OBJECT_ID(N'[dbo].[ErrorLogBackup]') IS NOT NULL DROP TABLE [dbo].[ErrorLogBackup];

IF OBJECT_ID(N'[procfwk].[ErrorLog]') IS NOT NULL --check for new deployments
BEGIN
	SELECT 
		*
	INTO
		[dbo].[ErrorLogBackup]
	FROM
		[procfwk].[ErrorLog];
END;

--delete all
--PipelineProcesses
IF EXISTS 
	(
	SELECT
		* 
	FROM
		sys.objects o
		INNER JOIN sys.schemas s
			ON o.[schema_id] = s.[schema_id]
	WHERE
		o.[name] = 'PipelineProcesses'
		AND s.[name] = 'procfwk'
		AND o.[type] = 'U' --Check for tables as created synonyms to support backwards compatability
	)
	BEGIN
		--drop just to avoid constraints
		IF OBJECT_ID(N'[procfwk].[PipelineParameters]') IS NOT NULL DROP TABLE [procfwk].[PipelineParameters];
		IF OBJECT_ID(N'[procfwk].[PipelineAuthLink]') IS NOT NULL DROP TABLE [procfwk].[PipelineAuthLink];

		SELECT * INTO [dbo].[zz_PipelineProcesses] FROM [procfwk].[PipelineProcesses];

		DROP TABLE [procfwk].[PipelineProcesses];
	END

--ProcessingStageDetails
IF EXISTS 
	(
	SELECT
		* 
	FROM
		sys.objects o
		INNER JOIN sys.schemas s
			ON o.[schema_id] = s.[schema_id]
	WHERE
		o.[name] = 'ProcessingStageDetails'
		AND s.[name] = 'procfwk'
		AND o.[type] = 'U' --Check for tables as created synonyms to support backwards compatability
	)
	BEGIN
		SELECT * INTO [dbo].[zz_ProcessingStageDetails] FROM [procfwk].[ProcessingStageDetails];
		
		DROP TABLE [procfwk].[ProcessingStageDetails];
	END;

--DataFactoryDetails
IF EXISTS 
	(
	SELECT
		* 
	FROM
		sys.objects o
		INNER JOIN sys.schemas s
			ON o.[schema_id] = s.[schema_id]
	WHERE
		o.[name] = 'DataFactoryDetails'
		AND s.[name] = 'procfwk'
		AND o.[type] = 'U' --Check for tables as created synonyms to support backwards compatability
	)
	BEGIN
		SELECT * INTO [dbo].[zz_DataFactoryDetails] FROM [procfwk].[DataFactoryDetails];
		
		DROP TABLE [procfwk].[DataFactoryDetails];
	END;
IF OBJECT_ID(N'tempdb..#DropLegacyObjects') IS NOT NULL DROP PROCEDURE #DropLegacyObjects;
GO

CREATE PROCEDURE #DropLegacyObjects
	(
	@ObjectName NVARCHAR(128),
	@ObjectType CHAR(2)
	)
AS
BEGIN
	DECLARE @DDLType NVARCHAR(128)

	IF EXISTS
		(
		SELECT
			*
		FROM
			sys.objects o
			INNER JOIN sys.schemas s
				ON o.[schema_id] = s.[schema_id]
		WHERE
			o.[Name] = @ObjectName
			AND s.[name] = 'procfwk'
			AND o.[type] = @ObjectType
		)
		BEGIN			
			SELECT
				@DDLType = CASE @ObjectType
								WHEN 'P' THEN 'PROCEDURE'
								WHEN 'V' THEN 'VIEW'
								WHEN 'FN' THEN 'FUNCTION'
							END;

			EXEC('DROP ' + @DDLType + ' [procfwk].[' + @ObjectName + '];')
		END;
END;
GO

EXEC #DropLegacyObjects 'AddProperty', 'P';
EXEC #DropLegacyObjects 'GetExecutionDetails', 'P';
EXEC #DropLegacyObjects 'AddRecipientPipelineAlerts', 'P';
EXEC #DropLegacyObjects 'DeleteRecipientAlerts', 'P';
EXEC #DropLegacyObjects 'CheckStageAndPiplineIntegrity', 'P';
EXEC #DropLegacyObjects 'AddPipelineDependant', 'P';
EXEC #DropLegacyObjects 'AddServicePrincipalWrapper', 'P';
EXEC #DropLegacyObjects 'AddServicePrincipalUrls', 'P';
EXEC #DropLegacyObjects 'AddServicePrincipal', 'P';
EXEC #DropLegacyObjects 'DeleteServicePrincipal', 'P';
EXEC #DropLegacyObjects 'CheckForValidURL', 'FN';
EXEC #DropLegacyObjects 'PipelineDependencyChains', 'V';
EXEC #DropLegacyObjects 'AverageStageDuration', 'V';
EXEC #DropLegacyObjects 'CompleteExecutionErrorLog', 'V';
EXEC #DropLegacyObjects 'CompleteExecutionLog', 'V';
EXEC #DropLegacyObjects 'CurrentExecutionSummary', 'V';
EXEC #DropLegacyObjects 'LastExecution', 'V';
EXEC #DropLegacyObjects 'LastExecutionSummary', 'V';
EXEC #DropLegacyObjects 'WorkerParallelismOverTime', 'V';

--replaced with new precursor concept in v1.8.5:
IF OBJECT_ID(N'[dbo].[SetRandomWaitValues]') IS NOT NULL DROP PROCEDURE [dbo].[SetRandomWaitValues];
	--CurrentExecution
	IF OBJECT_ID(N'[procfwk].[CurrentExecution]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[CurrentExecution];
		END;

	--ExecutionLog
	IF OBJECT_ID(N'[procfwk].[ExecutionLog]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[ExecutionLog];
		END

	--ErrorLog
	IF OBJECT_ID(N'[procfwk].[ExecutionLog]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[ErrorLog];
		END

	--PipelineDependencies
	IF OBJECT_ID(N'[procfwk].[PipelineDependencies]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineDependencies];
			DBCC CHECKIDENT ('[procfwk].[PipelineDependencies]', RESEED, 0);
		END;

	--PipelineAlertLink
	IF OBJECT_ID(N'[procfwk].[PipelineAlertLink]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineAlertLink];
			DBCC CHECKIDENT ('[procfwk].[PipelineAlertLink]', RESEED, 0);
		END;

	--Recipients
	IF OBJECT_ID(N'[procfwk].[Recipients]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Recipients];
			DBCC CHECKIDENT ('[procfwk].[Recipients]', RESEED, 0);
		END;

	--AlertOutcomes
	IF OBJECT_ID(N'[procfwk].[AlertOutcomes]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[AlertOutcomes];
		END;

	--PipelineAuthLink
	IF OBJECT_ID(N'[procfwk].[PipelineAuthLink]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineAuthLink];
			DBCC CHECKIDENT ('[procfwk].[PipelineAuthLink]', RESEED, 0);
		END;

	--ServicePrincipals
	IF OBJECT_ID(N'[dbo].[ServicePrincipals]') IS NOT NULL 
		BEGIN
			DELETE FROM [dbo].[ServicePrincipals];
			DBCC CHECKIDENT ('[dbo].[ServicePrincipals]', RESEED, 0);
		END;

	--Properties
	IF OBJECT_ID(N'[procfwk].[Properties]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Properties];
			DBCC CHECKIDENT ('[procfwk].[Properties]', RESEED, 0);
		END;

	--PipelineParameters
	IF OBJECT_ID(N'[procfwk].[PipelineParameters]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineParameters];
			DBCC CHECKIDENT ('[procfwk].[PipelineParameters]', RESEED, 0);
		END;

	--Pipelines
	IF OBJECT_ID(N'[procfwk].[Pipelines]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Pipelines];
			DBCC CHECKIDENT ('[procfwk].[Pipelines]', RESEED, 0);
		END;

	--DataFactorys
	IF OBJECT_ID(N'[procfwk].[DataFactorys]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[DataFactorys];
			DBCC CHECKIDENT ('[procfwk].[DataFactorys]', RESEED, 0);
		END;

	--Stages
	IF OBJECT_ID(N'[procfwk].[Stages]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Stages];
			DBCC CHECKIDENT ('[procfwk].[Stages]', RESEED, 0);
		END;
GO

GO
PRINT N'Creating [adf_procfwkuser]...';


GO

DROP ROLE IF EXISTS [adf_procfwkuser]
GO

CREATE ROLE [adf_procfwkuser] AUTHORIZATION [dbo];
GO

PRINT N'Creating [procfwk]...';
GO
DROP SCHEMA IF EXISTS [procfwk]
GO
CREATE SCHEMA [procfwk] AUTHORIZATION [dbo];
GO

PRINT N'Creating [procfwkTesting]...';
GO
DROP SCHEMA IF EXISTS [procfwkTesting]
GO
CREATE SCHEMA [procfwkTesting] AUTHORIZATION [dbo];
GO

PRINT N'Creating [procfwkHelpers]...';
GO
DROP SCHEMA IF EXISTS [procfwkHelpers]
GO
CREATE SCHEMA [procfwkHelpers] AUTHORIZATION [dbo];
GO

PRINT N'Creating [procfwkReporting]...';
GO
DROP SCHEMA IF EXISTS [procfwkReporting]
GO
CREATE SCHEMA [procfwkReporting] AUTHORIZATION [dbo];
GO

PRINT N'Creating [dbo].[ServicePrincipals]...';
GO
DROP TABLE IF EXISTS [dbo].[ServicePrincipals]
GO
CREATE TABLE [dbo].[ServicePrincipals] (
    [CredentialId]       INT              IDENTITY (1, 1) NOT NULL,
    [PrincipalName]      NVARCHAR (256)   NULL,
    [PrincipalId]        UNIQUEIDENTIFIER NULL,
    [PrincipalSecret]    VARBINARY (256)  NULL,
    [PrincipalIdUrl]     NVARCHAR (MAX)   NULL,
    [PrincipalSecretUrl] NVARCHAR (MAX)   NULL,
    CONSTRAINT [PK_ServicePrincipals] PRIMARY KEY CLUSTERED ([CredentialId] ASC)
);
GO

PRINT N'Creating [procfwk].[PipelineAuthLink]...';
GO
DROP TABLE IF EXISTS [procfwk].[PipelineAuthLink]
GO
CREATE TABLE [procfwk].[PipelineAuthLink] (
    [AuthId]        INT IDENTITY (1, 1) NOT NULL,
    [PipelineId]    INT NOT NULL,
    [DataFactoryId] INT NOT NULL,
    [CredentialId]  INT NOT NULL,
    CONSTRAINT [PK_PipelineAuthLink] PRIMARY KEY CLUSTERED ([AuthId] ASC)
);
GO

PRINT N'Creating [procfwk].[DataFactorys]...';
GO
DROP TABLE IF EXISTS [procfwk].[DataFactorys] 
GO
CREATE TABLE [procfwk].[DataFactorys] (
    [DataFactoryId]     INT            IDENTITY (1, 1) NOT NULL,
    [DataFactoryName]   NVARCHAR (200) NOT NULL,
    [ResourceGroupName] NVARCHAR (200) NOT NULL,
    [Description]       NVARCHAR (MAX) NULL,
    CONSTRAINT [PK_DataFactorys] PRIMARY KEY CLUSTERED ([DataFactoryId] ASC)
);
GO

PRINT N'Creating [procfwk].[Properties]...';
GO
DROP TABLE IF EXISTS  [procfwk].[Properties]
GO
CREATE TABLE [procfwk].[Properties] (
    [PropertyId]    INT            IDENTITY (1, 1) NOT NULL,
    [PropertyName]  VARCHAR (128)  NOT NULL,
    [PropertyValue] NVARCHAR (MAX) NOT NULL,
    [Description]   NVARCHAR (MAX) NULL,
    [ValidFrom]     DATETIME       NOT NULL,
    [ValidTo]       DATETIME       NULL,
    CONSTRAINT [PK_Properties] PRIMARY KEY CLUSTERED ([PropertyId] ASC, [PropertyName] ASC)
);


GO
PRINT N'Creating [procfwk].[Stages]...';


GO
CREATE TABLE [procfwk].[Stages] (
    [StageId]          INT            IDENTITY (1, 1) NOT NULL,
    [StageName]        VARCHAR (225)  NOT NULL,
    [StageDescription] VARCHAR (4000) NULL,
    [Enabled]          BIT            NOT NULL,
    CONSTRAINT [PK_Stages] PRIMARY KEY CLUSTERED ([StageId] ASC)
);


GO
PRINT N'Creating [procfwk].[ExecutionLog]...';


GO
CREATE TABLE [procfwk].[ExecutionLog] (
    [LogId]                  INT              IDENTITY (1, 1) NOT NULL,
    [LocalExecutionId]       UNIQUEIDENTIFIER NOT NULL,
    [StageId]                INT              NOT NULL,
    [PipelineId]             INT              NOT NULL,
    [CallingDataFactoryName] NVARCHAR (200)   NOT NULL,
    [ResourceGroupName]      NVARCHAR (200)   NOT NULL,
    [DataFactoryName]        NVARCHAR (200)   NOT NULL,
    [PipelineName]           NVARCHAR (200)   NOT NULL,
    [StartDateTime]          DATETIME         NULL,
    [PipelineStatus]         NVARCHAR (200)   NULL,
    [EndDateTime]            DATETIME         NULL,
    [AdfPipelineRunId]       UNIQUEIDENTIFIER NULL,
    [PipelineParamsUsed]     NVARCHAR (MAX)   NULL,
    CONSTRAINT [PK_ExecutionLog] PRIMARY KEY CLUSTERED ([LogId] ASC)
);


GO
PRINT N'Creating [procfwk].[CurrentExecution]...';


GO
CREATE TABLE [procfwk].[CurrentExecution] (
    [LocalExecutionId]        UNIQUEIDENTIFIER NOT NULL,
    [StageId]                 INT              NOT NULL,
    [PipelineId]              INT              NOT NULL,
    [CallingDataFactoryName]  NVARCHAR (200)   NOT NULL,
    [ResourceGroupName]       NVARCHAR (200)   NOT NULL,
    [DataFactoryName]         NVARCHAR (200)   NOT NULL,
    [PipelineName]            NVARCHAR (200)   NOT NULL,
    [StartDateTime]           DATETIME         NULL,
    [PipelineStatus]          NVARCHAR (200)   NULL,
    [LastStatusCheckDateTime] DATETIME         NULL,
    [EndDateTime]             DATETIME         NULL,
    [IsBlocked]               BIT              NOT NULL,
    [AdfPipelineRunId]        UNIQUEIDENTIFIER NULL,
    [PipelineParamsUsed]      NVARCHAR (MAX)   NULL,
    CONSTRAINT [PK_CurrentExecution] PRIMARY KEY CLUSTERED ([LocalExecutionId] ASC, [StageId] ASC, [PipelineId] ASC)
);


GO
PRINT N'Creating [procfwk].[CurrentExecution].[IDX_GetPipelinesInStage]...';


GO
CREATE NONCLUSTERED INDEX [IDX_GetPipelinesInStage]
    ON [procfwk].[CurrentExecution]([StageId] ASC, [PipelineStatus] ASC)
    INCLUDE([PipelineId], [PipelineName], [DataFactoryName], [ResourceGroupName]);
GO

PRINT N'Creating [procfwk].[PipelineParameters]...';
GO
CREATE TABLE [procfwk].[PipelineParameters] (
    [ParameterId]    INT            IDENTITY (1, 1) NOT NULL,
    [PipelineId]     INT            NOT NULL,
    [ParameterName]  VARCHAR (128)  NOT NULL,
    [ParameterValue] NVARCHAR (MAX) NULL,
    CONSTRAINT [PK_PipelineParameters] PRIMARY KEY CLUSTERED ([ParameterId] ASC)
);
GO

PRINT N'Creating [procfwk].[Pipelines]...';
GO
CREATE TABLE [procfwk].[Pipelines] (
    [PipelineId]           INT            IDENTITY (1, 1) NOT NULL,
    [DataFactoryId]        INT            NOT NULL,
    [StageId]              INT            NOT NULL,
    [PipelineName]         NVARCHAR (200) NOT NULL,
    [LogicalPredecessorId] INT            NULL,
    [Enabled]              BIT            NOT NULL,
    CONSTRAINT [PK_Pipelines] PRIMARY KEY CLUSTERED ([PipelineId] ASC)
);
GO

PRINT N'Creating [procfwk].[AlertOutcomes]...';
GO
CREATE TABLE [procfwk].[AlertOutcomes] (
    [OutcomeBitPosition]    INT            IDENTITY (0, 1) NOT NULL,
    [PipelineOutcomeStatus] NVARCHAR (200) NOT NULL,
    [BitValue]              AS             (POWER((2), [OutcomeBitPosition])),
    CONSTRAINT [PK_AlertOutcomes] PRIMARY KEY CLUSTERED ([OutcomeBitPosition] ASC),
    CONSTRAINT [UK_PipelineOutcomeStatus] UNIQUE NONCLUSTERED ([PipelineOutcomeStatus] ASC)
);
GO

PRINT N'Creating [procfwk].[PipelineAlertLink]...';
GO
CREATE TABLE [procfwk].[PipelineAlertLink] (
    [AlertId]          INT IDENTITY (1, 1) NOT NULL,
    [PipelineId]       INT NOT NULL,
    [RecipientId]      INT NOT NULL,
    [OutcomesBitValue] INT NOT NULL,
    [Enabled]          BIT NOT NULL,
    CONSTRAINT [PK_PipelineAlertLink] PRIMARY KEY CLUSTERED ([AlertId] ASC)
);


GO
PRINT N'Creating [procfwk].[Recipients]...';


GO
CREATE TABLE [procfwk].[Recipients] (
    [RecipientId]       INT            IDENTITY (1, 1) NOT NULL,
    [Name]              VARCHAR (255)  NULL,
    [EmailAddress]      NVARCHAR (500) NOT NULL,
    [MessagePreference] CHAR (3)       NOT NULL,
    [Enabled]           BIT            NOT NULL,
    CONSTRAINT [PK_Recipients] PRIMARY KEY CLUSTERED ([RecipientId] ASC),
    CONSTRAINT [UK_EmailAddressMessagePreference] UNIQUE NONCLUSTERED ([EmailAddress] ASC, [MessagePreference] ASC)
);


GO
PRINT N'Creating [procfwk].[ErrorLog]...';


GO
CREATE TABLE [procfwk].[ErrorLog] (
    [LogId]            INT              IDENTITY (1, 1) NOT NULL,
    [LocalExecutionId] UNIQUEIDENTIFIER NOT NULL,
    [AdfPipelineRunId] UNIQUEIDENTIFIER NOT NULL,
    [ActivityRunId]    UNIQUEIDENTIFIER NOT NULL,
    [ActivityName]     VARCHAR (100)    NOT NULL,
    [ActivityType]     VARCHAR (100)    NOT NULL,
    [ErrorCode]        VARCHAR (100)    NOT NULL,
    [ErrorType]        VARCHAR (100)    NOT NULL,
    [ErrorMessage]     NVARCHAR (MAX)   NULL,
    CONSTRAINT [PK_ErrorLog] PRIMARY KEY CLUSTERED ([LogId] ASC)
);


GO
PRINT N'Creating [procfwk].[PipelineDependencies]...';


GO
CREATE TABLE [procfwk].[PipelineDependencies] (
    [DependencyId]        INT IDENTITY (1, 1) NOT NULL,
    [PipelineId]          INT NOT NULL,
    [DependantPipelineId] INT NOT NULL,
    CONSTRAINT [PK_PipelineDependencies] PRIMARY KEY CLUSTERED ([DependencyId] ASC),
    CONSTRAINT [UK_PipelinesToDependantPipelines] UNIQUE NONCLUSTERED ([PipelineId] ASC, [DependantPipelineId] ASC)
);


GO
PRINT N'Creating [procfwk].[DataFactoryDetails]...';


GO
CREATE SYNONYM [procfwk].[DataFactoryDetails] FOR [procfwk].[DataFactorys];


GO
PRINT N'Creating [procfwk].[ProcessingStageDetails]...';


GO
CREATE SYNONYM [procfwk].[ProcessingStageDetails] FOR [procfwk].[Stages];


GO
PRINT N'Creating [procfwk].[PipelineProcesses]...';


GO
CREATE SYNONYM [procfwk].[PipelineProcesses] FOR [procfwk].[Pipelines];


GO
PRINT N'Creating [procfwk].[DF_Properties_ValidFrom]...';


GO
ALTER TABLE [procfwk].[Properties]
    ADD CONSTRAINT [DF_Properties_ValidFrom] DEFAULT (GETDATE()) FOR [ValidFrom];


GO
PRINT N'Creating [procfwk].[DF_Stages_Enabled]...';


GO
ALTER TABLE [procfwk].[Stages]
    ADD CONSTRAINT [DF_Stages_Enabled] DEFAULT ((1)) FOR [Enabled];


GO
PRINT N'Creating unnamed constraint on [procfwk].[ExecutionLog]...';


GO
ALTER TABLE [procfwk].[ExecutionLog]
    ADD DEFAULT ('Unknown') FOR [CallingDataFactoryName];


GO
PRINT N'Creating unnamed constraint on [procfwk].[ExecutionLog]...';


GO
ALTER TABLE [procfwk].[ExecutionLog]
    ADD DEFAULT ('Unknown') FOR [ResourceGroupName];


GO
PRINT N'Creating unnamed constraint on [procfwk].[ExecutionLog]...';


GO
ALTER TABLE [procfwk].[ExecutionLog]
    ADD DEFAULT ('Unknown') FOR [DataFactoryName];


GO
PRINT N'Creating unnamed constraint on [procfwk].[ExecutionLog]...';


GO
ALTER TABLE [procfwk].[ExecutionLog]
    ADD DEFAULT ('None') FOR [PipelineParamsUsed];


GO
PRINT N'Creating unnamed constraint on [procfwk].[CurrentExecution]...';


GO
ALTER TABLE [procfwk].[CurrentExecution]
    ADD DEFAULT 0 FOR [IsBlocked];


GO
PRINT N'Creating [procfwk].[DF_Pipelines_Enabled]...';


GO
ALTER TABLE [procfwk].[Pipelines]
    ADD CONSTRAINT [DF_Pipelines_Enabled] DEFAULT ((1)) FOR [Enabled];


GO
PRINT N'Creating unnamed constraint on [procfwk].[PipelineAlertLink]...';


GO
ALTER TABLE [procfwk].[PipelineAlertLink]
    ADD DEFAULT 1 FOR [Enabled];


GO
PRINT N'Creating unnamed constraint on [procfwk].[Recipients]...';


GO
ALTER TABLE [procfwk].[Recipients]
    ADD DEFAULT ('TO') FOR [MessagePreference];


GO
PRINT N'Creating unnamed constraint on [procfwk].[Recipients]...';


GO
ALTER TABLE [procfwk].[Recipients]
    ADD DEFAULT 1 FOR [Enabled];


GO
PRINT N'Creating [procfwk].[FK_PipelineAuthLink_DataFactorys]...';


GO
ALTER TABLE [procfwk].[PipelineAuthLink]
    ADD CONSTRAINT [FK_PipelineAuthLink_DataFactorys] FOREIGN KEY ([DataFactoryId]) REFERENCES [procfwk].[DataFactorys] ([DataFactoryId]);


GO
PRINT N'Creating [procfwk].[FK_PipelineAuthLink_Pipelines]...';


GO
ALTER TABLE [procfwk].[PipelineAuthLink]
    ADD CONSTRAINT [FK_PipelineAuthLink_Pipelines] FOREIGN KEY ([PipelineId]) REFERENCES [procfwk].[Pipelines] ([PipelineId]);


GO
PRINT N'Creating [procfwk].[FK_PipelineAuthLink_ServicePrincipals]...';


GO
ALTER TABLE [procfwk].[PipelineAuthLink]
    ADD CONSTRAINT [FK_PipelineAuthLink_ServicePrincipals] FOREIGN KEY ([CredentialId]) REFERENCES [dbo].[ServicePrincipals] ([CredentialId]);


GO
PRINT N'Creating [procfwk].[FK_PipelineParameters_Pipelines]...';


GO
ALTER TABLE [procfwk].[PipelineParameters]
    ADD CONSTRAINT [FK_PipelineParameters_Pipelines] FOREIGN KEY ([PipelineId]) REFERENCES [procfwk].[Pipelines] ([PipelineId]);


GO
PRINT N'Creating [procfwk].[FK_Pipelines_Stages]...';


GO
ALTER TABLE [procfwk].[Pipelines]
    ADD CONSTRAINT [FK_Pipelines_Stages] FOREIGN KEY ([StageId]) REFERENCES [procfwk].[Stages] ([StageId]);


GO
PRINT N'Creating [procfwk].[FK_Pipelines_DataFactorys]...';


GO
ALTER TABLE [procfwk].[Pipelines]
    ADD CONSTRAINT [FK_Pipelines_DataFactorys] FOREIGN KEY ([DataFactoryId]) REFERENCES [procfwk].[DataFactorys] ([DataFactoryId]);


GO
PRINT N'Creating [procfwk].[FK_Pipelines_Pipelines]...';


GO
ALTER TABLE [procfwk].[Pipelines]
    ADD CONSTRAINT [FK_Pipelines_Pipelines] FOREIGN KEY ([LogicalPredecessorId]) REFERENCES [procfwk].[Pipelines] ([PipelineId]);


GO
PRINT N'Creating [procfwk].[FK_PipelineAlertLink_Pipelines]...';


GO
ALTER TABLE [procfwk].[PipelineAlertLink]
    ADD CONSTRAINT [FK_PipelineAlertLink_Pipelines] FOREIGN KEY ([PipelineId]) REFERENCES [procfwk].[Pipelines] ([PipelineId]);


GO
PRINT N'Creating [procfwk].[FK_PipelineAlertLink_Recipients]...';


GO
ALTER TABLE [procfwk].[PipelineAlertLink]
    ADD CONSTRAINT [FK_PipelineAlertLink_Recipients] FOREIGN KEY ([RecipientId]) REFERENCES [procfwk].[Recipients] ([RecipientId]);


GO
PRINT N'Creating [procfwk].[FK_PipelineDependencies_Pipelines]...';


GO
ALTER TABLE [procfwk].[PipelineDependencies]
    ADD CONSTRAINT [FK_PipelineDependencies_Pipelines] FOREIGN KEY ([PipelineId]) REFERENCES [procfwk].[Pipelines] ([PipelineId]);


GO
PRINT N'Creating [procfwk].[FK_PipelineDependencies_Pipelines1]...';


GO
ALTER TABLE [procfwk].[PipelineDependencies]
    ADD CONSTRAINT [FK_PipelineDependencies_Pipelines1] FOREIGN KEY ([DependantPipelineId]) REFERENCES [procfwk].[Pipelines] ([PipelineId]);


GO
PRINT N'Creating [procfwk].[MessagePreferenceValue]...';


GO
ALTER TABLE [procfwk].[Recipients]
    ADD CONSTRAINT [MessagePreferenceValue] CHECK ([MessagePreference] IN ('TO','CC','BCC'));


GO
PRINT N'Creating [procfwk].[EQ_PipelineIdDependantPipelineId]...';


GO
ALTER TABLE [procfwk].[PipelineDependencies]
    ADD CONSTRAINT [EQ_PipelineIdDependantPipelineId] CHECK ([PipelineId] <> [DependantPipelineId]);


GO
PRINT N'Creating [procfwk].[AddServicePrincipalWrapper]...';


GO
CREATE SYNONYM [procfwk].[AddServicePrincipalWrapper] FOR [procfwkHelpers].[AddServicePrincipalWrapper];


GO
PRINT N'Creating [procfwk].[AddServicePrincipalUrls]...';


GO
CREATE SYNONYM [procfwk].[AddServicePrincipalUrls] FOR [procfwkHelpers].[AddServicePrincipalUrls];


GO
PRINT N'Creating [procfwk].[AddServicePrincipal]...';


GO
CREATE SYNONYM [procfwk].[AddServicePrincipal] FOR [procfwkHelpers].[AddServicePrincipal];


GO
PRINT N'Creating [procfwk].[AddRecipientPipelineAlerts]...';


GO
CREATE SYNONYM [procfwk].[AddRecipientPipelineAlerts] FOR [procfwkHelpers].[AddRecipientPipelineAlerts];


GO
PRINT N'Creating [procfwk].[AddProperty]...';


GO
CREATE SYNONYM [procfwk].[AddProperty] FOR [procfwkHelpers].[AddProperty];


GO
PRINT N'Creating [procfwk].[AddPipelineDependant]...';


GO
CREATE SYNONYM [procfwk].[AddPipelineDependant] FOR [procfwkHelpers].[AddPipelineDependant];


GO
PRINT N'Creating [procfwk].[PipelineDependencyChains]...';


GO
CREATE SYNONYM [procfwk].[PipelineDependencyChains] FOR [procfwkHelpers].[PipelineDependencyChains];


GO
PRINT N'Creating [procfwk].[WorkerParallelismOverTime]...';


GO
CREATE SYNONYM [procfwk].[WorkerParallelismOverTime] FOR [procfwkReporting].[WorkerParallelismOverTime];


GO
PRINT N'Creating [procfwk].[LastExecutionSummary]...';


GO
CREATE SYNONYM [procfwk].[LastExecutionSummary] FOR [procfwkReporting].[LastExecutionSummary];


GO
PRINT N'Creating [procfwk].[LastExecution]...';


GO
CREATE SYNONYM [procfwk].[LastExecution] FOR [procfwkReporting].[LastExecution];


GO
PRINT N'Creating [procfwk].[CurrentExecutionSummary]...';


GO
CREATE SYNONYM [procfwk].[CurrentExecutionSummary] FOR [procfwkReporting].[CurrentExecutionSummary];


GO
PRINT N'Creating [procfwk].[CompleteExecutionLog]...';


GO
CREATE SYNONYM [procfwk].[CompleteExecutionLog] FOR [procfwkReporting].[CompleteExecutionLog];


GO
PRINT N'Creating [procfwk].[CompleteExecutionErrorLog]...';


GO
CREATE SYNONYM [procfwk].[CompleteExecutionErrorLog] FOR [procfwkReporting].[CompleteExecutionErrorLog];


GO
PRINT N'Creating [procfwk].[AverageStageDuration]...';


GO
CREATE SYNONYM [procfwk].[AverageStageDuration] FOR [procfwkReporting].[AverageStageDuration];


GO
PRINT N'Creating [procfwk].[GetExecutionDetails]...';


GO
CREATE SYNONYM [procfwk].[GetExecutionDetails] FOR [procfwkHelpers].[GetExecutionDetails];


GO
PRINT N'Creating [procfwk].[DeleteServicePrincipal]...';


GO
CREATE SYNONYM [procfwk].[DeleteServicePrincipal] FOR [procfwkHelpers].[DeleteServicePrincipal];


GO
PRINT N'Creating [procfwk].[DeleteRecipientAlerts]...';


GO
CREATE SYNONYM [procfwk].[DeleteRecipientAlerts] FOR [procfwkHelpers].[DeleteRecipientAlerts];


GO
PRINT N'Creating [procfwk].[CheckStageAndPiplineIntegrity]...';


GO
CREATE SYNONYM [procfwk].[CheckStageAndPiplineIntegrity] FOR [procfwkHelpers].[CheckStageAndPiplineIntegrity];


GO
PRINT N'Creating [procfwk].[CheckForValidURL]...';


GO
CREATE SYNONYM [procfwk].[CheckForValidURL] FOR [procfwkHelpers].[CheckForValidURL];


GO
PRINT N'Creating [procfwk].[CurrentProperties]...';


GO
CREATE VIEW [procfwk].[CurrentProperties]
AS

SELECT
	[PropertyName],
	[PropertyValue]
FROM
	[procfwk].[Properties]
WHERE
	[ValidTo] IS NULL;
GO
PRINT N'Creating [procfwk].[PipelineParameterDataSizes]...';


GO
CREATE VIEW [procfwk].[PipelineParameterDataSizes]
AS

SELECT 
	[PipelineId],
	SUM(
		(CAST(
			DATALENGTH(
				STRING_ESCAPE([ParameterName] + [ParameterValue],'json')) AS DECIMAL)
			/1024) --KB
			/1024 --MB
		) AS Size
FROM 
	[procfwk].[PipelineParameters]
GROUP BY
	[PipelineId];
GO
PRINT N'Creating [procfwkHelpers].[PipelineDependencyChains]...';


GO
CREATE VIEW [procfwkHelpers].[PipelineDependencyChains]
AS

SELECT 
	ps.[StageName] AS PredecessorStage,
	pp.[PipelineName] AS PredecessorPipeline,
	ds.[StageName] AS DependantStage,
	dp.[PipelineName] AS DependantPipeline
FROM 
	[procfwk].[PipelineDependencies]					pd --pipeline dependencies
	INNER JOIN [procfwk].[Pipelines]					pp --predecessor pipelines
		ON pd.[PipelineId] = pp.[PipelineId]
	INNER JOIN [procfwk].[Pipelines]					dp --dependant pipelines
		ON pd.[DependantPipelineId] = dp.[PipelineId]
	INNER JOIN [procfwk].[Stages]						ps --predecessor stage
		ON pp.[StageId] = ps.[StageId]
	INNER JOIN [procfwk].[Stages]						ds --dependant stage
		ON dp.[StageId] = ds.[StageId];
GO
PRINT N'Creating [procfwkReporting].[WorkerParallelismOverTime]...';


GO
CREATE VIEW [procfwkReporting].[WorkerParallelismOverTime]
AS

WITH numbers AS
	(
	SELECT TOP 500
		ROW_NUMBER() OVER (ORDER BY s1.[object_id]) - 1 AS 'Number'
	FROM 
		sys.all_columns AS s1
		CROSS JOIN sys.all_columns AS s2
	),
	executionBoundaries AS
	(
	SELECT
		[LocalExecutionId],
		CAST(CONVERT(VARCHAR(16), MIN([StartDateTime]), 120) AS DATETIME)  AS 'ExecutionStart',
		CAST(CONVERT(VARCHAR(16), MAX([EndDateTime]), 120) AS DATETIME) AS 'ExecutionEnd'
	FROM
		[procfwk].[ExecutionLog]
	--WHERE
	--	[LocalExecutionId] = '2BB02783-2A2C-4970-9BEA-0543013BFD5E'
	GROUP BY
		[LocalExecutionId]
	),
	wallclockRunning AS
	(
	SELECT
		CAST(DATEADD(MINUTE, n.[Number], eB.[ExecutionStart]) AS DATE) AS 'WallclockDate',
		CAST(DATEADD(MINUTE, n.[Number], eB.[ExecutionStart]) AS TIME) AS 'WallclockTime',
		el.[LocalExecutionId],
		el.[PipelineId],
		el.[PipelineName],
		s.[StageName]
	FROM
		executionBoundaries eB
		CROSS JOIN numbers n
		INNER JOIN [procfwk].[ExecutionLog] eL
			ON eB.[LocalExecutionId] = eL.[LocalExecutionId]
				AND DATEADD(MINUTE, n.[Number], eB.[ExecutionStart]) 
					BETWEEN eL.[StartDateTime] AND eL.[EndDateTime]
		INNER JOIN [procfwk].[Stages] s
			ON eL.[StageId] = s.[StageId]
	)

SELECT
	[WallclockDate],
	[WallclockTime],
	[LocalExecutionId],
	[StageName],
	STRING_AGG(ISNULL([PipelineName],' '),', ') As 'PipelineName',
	COUNT([PipelineId]) AS 'WorkerCount'
FROM
	wallclockRunning
GROUP BY
	[WallclockDate],
	[WallclockTime],
	[LocalExecutionId],
	[StageName]
GO
PRINT N'Creating [procfwkReporting].[LastExecutionSummary]...';


GO
CREATE VIEW [procfwkReporting].[LastExecutionSummary]
AS

WITH maxLog AS
	(
	SELECT
		MAX([LogId]) AS 'MaxLogId'
	FROM
		[procfwk].[ExecutionLog]
	),
	lastExecutionId AS
	(
	SELECT
		[LocalExecutionId]
	FROM
		[procfwk].[ExecutionLog] el1
		INNER JOIN maxLog
			ON maxLog.[MaxLogId] = el1.[LogId]
	)
SELECT
	el2.[LocalExecutionId],
	DATEDIFF(MINUTE, MIN(el2.[StartDateTime]), MAX(el2.[EndDateTime])) 'RunDurationMinutes'
FROM 
	[procfwk].[ExecutionLog] el2
	INNER JOIN lastExecutionId
		ON el2.[LocalExecutionId] = lastExecutionId.[LocalExecutionId]
GROUP BY
	el2.[LocalExecutionId]
GO
PRINT N'Creating [procfwkReporting].[LastExecution]...';


GO
CREATE VIEW [procfwkReporting].[LastExecution]
AS

WITH maxLog AS
	(
	SELECT
		MAX([LogId]) AS 'MaxLogId'
	FROM
		[procfwk].[ExecutionLog]
	),
	lastExecutionId AS
	(
	SELECT
		[LocalExecutionId]
	FROM
		[procfwk].[ExecutionLog] el1
		INNER JOIN maxLog
			ON maxLog.[MaxLogId] = el1.[LogId]
	)
SELECT
	el2.[LogId],
	el2.[StageId],
	el2.[PipelineId],
	el2.[PipelineName],
	el2.[StartDateTime],
	el2.[PipelineStatus],
	el2.[EndDateTime],
	DATEDIFF(MINUTE, el2.[StartDateTime], el2.[EndDateTime]) AS RunDurationMinutes
FROM 
	[procfwk].[ExecutionLog] el2
	INNER JOIN lastExecutionId
		ON el2.[LocalExecutionId] = lastExecutionId.[LocalExecutionId]
WHERE
	el2.[EndDateTime] IS NOT NULL;
GO
PRINT N'Creating [procfwkReporting].[CurrentExecutionSummary]...';


GO
CREATE VIEW [procfwkReporting].[CurrentExecutionSummary]
AS

SELECT 
	ISNULL([PipelineStatus], 'Not Started') AS 'PipelineStatus',
	COUNT(0) AS 'RecordCount'
FROM 
	[procfwk].[CurrentExecution]
GROUP BY
	[PipelineStatus]
GO
PRINT N'Creating [procfwkReporting].[CompleteExecutionLog]...';


GO
CREATE VIEW [procfwkReporting].[CompleteExecutionLog]
AS

SELECT
	[LogId],
	[LocalExecutionId],
	[StageId],
	[PipelineId],
	[CallingDataFactoryName],
	[ResourceGroupName],
	[DataFactoryName],
	[PipelineName],
	[StartDateTime],
	[PipelineStatus],
	[EndDateTime],
	DATEDIFF(MINUTE, [StartDateTime], [EndDateTime]) 'RunDurationMinutes'
FROM 
	[procfwk].[ExecutionLog]
GO
PRINT N'Creating [procfwkReporting].[CompleteExecutionErrorLog]...';


GO
CREATE VIEW [procfwkReporting].[CompleteExecutionErrorLog]
AS

SELECT
	exeLog.[LogId] AS 'ExecutionLogId',
	errLog.[LogId] AS 'ErrorLogId',
	exeLog.[LocalExecutionId],
	exeLog.[StartDateTime] AS 'ProcessingDateTime',
	exeLog.[CallingDataFactoryName],
	exeLog.[DataFactoryName] AS 'WorkerDataFactory',
	exeLog.[PipelineName] AS 'WorkerPipelineName',
	exeLog.[PipelineStatus],
	errLog.[ActivityRunId],
	errLog.[ActivityName],
	errLog.[ActivityType],
	errLog.[ErrorCode],
	errLog.[ErrorType],
	errLog.[ErrorMessage]
FROM
	[procfwk].[ExecutionLog] exeLog
	INNER JOIN [procfwk].[ErrorLog] errLog
		ON exeLog.[LocalExecutionId] = errLog.[LocalExecutionId]
			AND exeLog.[AdfPipelineRunId] = errLog.[AdfPipelineRunId]
	INNER JOIN [procfwk].[Stages] stgs
		ON exeLog.[StageId] = stgs.[StageId]
;
GO
PRINT N'Creating [procfwkReporting].[AverageStageDuration]...';


GO
CREATE VIEW [procfwkReporting].[AverageStageDuration]
AS

WITH stageStartEnd AS
	(
	SELECT
		[LocalExecutionId],
		[StageId],
		MIN([StartDateTime]) AS 'StageStart',
		MAX([EndDateTime]) AS 'StageEnd'
	FROM
		[procfwk].[ExecutionLog]
	GROUP BY
		[LocalExecutionId],
		[StageId]
	)

SELECT
	s.[StageId],
	s.[StageName],
	s.[StageDescription],
	AVG(DATEDIFF(MINUTE, stageStartEnd.[StageStart], stageStartEnd.[StageEnd])) 'AvgStageRunDurationMinutes'
FROM
	stageStartEnd
	INNER JOIN [procfwk].[Stages] s
		ON stageStartEnd.[StageId] = s.[StageId]
GROUP BY
	s.[StageId],
	s.[StageName],
	s.[StageDescription]
GO
PRINT N'Creating [procfwk].[GetPropertyValueInternal]...';


GO
CREATE FUNCTION [procfwk].[GetPropertyValueInternal]
	(
	@PropertyName VARCHAR(128)
	)
RETURNS NVARCHAR(MAX)
AS
BEGIN
	DECLARE @PropertyValue NVARCHAR(MAX)

	SELECT
		@PropertyValue = ISNULL([PropertyValue],'')
	FROM
		[procfwk].[CurrentProperties]
	WHERE
		[PropertyName] = @PropertyName

    RETURN @PropertyValue
END;
GO
PRINT N'Creating [procfwkHelpers].[CheckForValidURL]...';


GO
CREATE FUNCTION [procfwkHelpers].[CheckForValidURL] (@Url NVARCHAR(MAX))
RETURNS INT
AS
BEGIN
    DECLARE @Ending VARCHAR(50)
	DECLARE @TempString VARCHAR(50)

	--check URL start
	IF CHARINDEX('https://', @Url) <> 1
    BEGIN
        RETURN 0;
    END

	--check for expected sub domains
    IF CHARINDEX('vault.azure.net', @Url) = 0
    BEGIN
        RETURN 0;
    END

	--check for expected value type
    IF CHARINDEX('secrets', @Url) = 0
    BEGIN
		RETURN 0;
    END
    
	--attempt to check for secret version 
	SELECT 
		@Ending = 
			CASE
				WHEN RIGHT(@Url,1) = '/' THEN REVERSE(LEFT(@Url,LEN(@Url)-1))
				ELSE REVERSE(@Url)
			END,
		@Ending = REVERSE(LEFT(@Ending,CHARINDEX('/',@Ending)-1))

		IF LEN(@Ending) = 32            
		BEGIN            
    		SET @TempString = 
				SUBSTRING(@Ending, 1, 8) + '-' + 
				SUBSTRING(@Ending, 9, 4) + '-' +             
    			SUBSTRING(@Ending, 13, 4) + '-' + 
				SUBSTRING(@Ending, 13, 4) + '-' + 
				SUBSTRING(@Ending, 20, 12)            
		END
	
		IF TRY_CAST(@TempString AS UNIQUEIDENTIFIER) IS NOT NULL 
		BEGIN
			RETURN 0;
		END;

	-- It is a valid URL
    RETURN 1;
END;
GO
PRINT N'Creating [dbo].[FailProcedure]...';


GO
CREATE PROCEDURE [dbo].[FailProcedure]
	(
	@RaiseError VARCHAR(50)
	)
AS
BEGIN
	IF(@RaiseError = 'true')
	BEGIN
		RAISERROR('The Stored Procedure intentionally failed.',16,1);
		RETURN 0;
	END
END;
GO
PRINT N'Creating [dbo].[ExampleCustomExecutionPrecursor]...';


GO
CREATE PROCEDURE [dbo].[ExampleCustomExecutionPrecursor]
AS
BEGIN
	
	--set random Worker pipeline parameter wait times for development environment
	;WITH cte AS
		(
		SELECT 
			[PipelineId],
			LEFT(ABS(CAST(CAST(NEWID() AS VARBINARY(192)) AS INT)),2) AS NewValue
		FROM 
			[procfwk].[PipelineParameters]
		)
	UPDATE
		pp
	SET
		pp.[ParameterValue] = cte.[NewValue]
	FROM
		[procfwk].[PipelineParameters] pp
		INNER JOIN cte
			ON pp.[PipelineId] = cte.[PipelineId]
		INNER JOIN [procfwk].[Pipelines] p
			ON pp.[PipelineId] = p.[PipelineId]
	WHERE
		p.[PipelineName] LIKE 'Wait%'
		AND p.[Enabled] = 1;


	--disable certain Workers if running at the weekend...
	-- YOUR CODE HERE

	--enable certain Workers if running on the 10th day of the month...
	-- YOUR CODE HERE

	--disable certain Stages if running on Friday...
	-- YOUR CODE HERE

	--set Worker pipeline parameters to new value based on ______ ....
	-- YOUR CODE HERE
	
	--etc
END;
GO
PRINT N'Creating [procfwk].[GetServicePrincipal]...';


GO
CREATE PROCEDURE [procfwk].[GetServicePrincipal]
	(
	@DataFactory NVARCHAR(200),
	@PipelineName NVARCHAR(200) = NULL
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @Id NVARCHAR(MAX)
	DECLARE @Secret NVARCHAR(MAX)
	DECLARE @TenantId CHAR(36)

	IF ([procfwk].[GetPropertyValueInternal]('SPNHandlingMethod')) = 'StoreInDatabase'
		BEGIN
			--get tenant Id to include in decryption
			SELECT
				@TenantId = [procfwk].[GetPropertyValueInternal]('TenantId');

			--get auth details regardless of being pipeline specific and regardless of a pipeline param being passed
			;WITH cte AS
				(
				SELECT DISTINCT
					S.[PrincipalId] AS Id,
					CAST(DECRYPTBYPASSPHRASE(CONCAT(@TenantId, @DataFactory, @PipelineName), S.[PrincipalSecret]) AS NVARCHAR(MAX)) AS [Secret]
				FROM
					[dbo].[ServicePrincipals] S
					INNER JOIN  [procfwk].[PipelineAuthLink] L
						ON S.[CredentialId] = L.[CredentialId]
					INNER JOIN [procfwk].[Pipelines] P
						ON L.[PipelineId] = P.[PipelineId]
					INNER JOIN [procfwk].[DataFactorys] D
						ON P.[DataFactoryId] = D.[DataFactoryId]
							AND L.[DataFactoryId] = D.[DataFactoryId]
				WHERE
					P.[PipelineName] = @PipelineName
					AND D.[DataFactoryName] = @DataFactory
			
				UNION

				SELECT DISTINCT
					S.[PrincipalId] AS Id,
					CAST(DECRYPTBYPASSPHRASE(CONCAT(@TenantId, @DataFactory), S.[PrincipalSecret]) AS NVARCHAR(MAX)) AS [Secret]
				FROM
					[dbo].[ServicePrincipals] S
					INNER JOIN  [procfwk].[PipelineAuthLink] L
						ON S.[CredentialId] = L.[CredentialId]
					INNER JOIN [procfwk].[DataFactorys] D
						ON L.[DataFactoryId] = D.[DataFactoryId]
							AND L.[DataFactoryId] = D.[DataFactoryId]
				WHERE
					D.[DataFactoryName] = @DataFactory
				)
			SELECT TOP 1
				@Id = [Id],
				@Secret = [Secret]
			FROM
				cte
			WHERE
				[Secret] IS NOT NULL
		END
	ELSE IF ([procfwk].[GetPropertyValueInternal]('SPNHandlingMethod')) = 'StoreInKeyVault'
		BEGIN
			
			--get auth details regardless of being pipeline specific and regardless of a pipeline param being passed
			;WITH cte AS
				(
				SELECT DISTINCT
					S.[PrincipalIdUrl] AS Id,
					S.[PrincipalSecretUrl] AS [Secret]
				FROM
					[dbo].[ServicePrincipals] S
					INNER JOIN  [procfwk].[PipelineAuthLink] L
						ON S.[CredentialId] = L.[CredentialId]
					INNER JOIN [procfwk].[Pipelines] P
						ON L.[PipelineId] = P.[PipelineId]
					INNER JOIN [procfwk].[DataFactorys] D
						ON P.[DataFactoryId] = D.[DataFactoryId]
							AND L.[DataFactoryId] = D.[DataFactoryId]
				WHERE
					P.[PipelineName] = @PipelineName
					AND D.[DataFactoryName] = @DataFactory
			
				UNION

				SELECT DISTINCT
					S.[PrincipalIdUrl] AS Id,
					S.[PrincipalSecretUrl] AS [Secret]
				FROM
					[dbo].[ServicePrincipals] S
					INNER JOIN  [procfwk].[PipelineAuthLink] L
						ON S.[CredentialId] = L.[CredentialId]
					INNER JOIN [procfwk].[DataFactorys] D
						ON L.[DataFactoryId] = D.[DataFactoryId]
							AND L.[DataFactoryId] = D.[DataFactoryId]
				WHERE
					D.[DataFactoryName] = @DataFactory
				)
			SELECT TOP 1
				@Id = [Id],
				@Secret = [Secret]
			FROM
				cte
			WHERE
				[Secret] IS NOT NULL
		END
	ELSE
		BEGIN
			RAISERROR('Unknown SPN retrieval method.',16,1);
			RETURN 0;
		END

	--return usable values
	SELECT
		@Id AS Id,
		@Secret AS [Secret]
END;
GO
PRINT N'Creating [procfwk].[GetPropertyValue]...';


GO
CREATE PROCEDURE [procfwk].[GetPropertyValue]
	(
	@PropertyName VARCHAR(128)
	)
AS
BEGIN	
	DECLARE @ErrorDetail NVARCHAR(4000) = ''

	--defensive checks
	IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[Properties] WHERE [PropertyName] = @PropertyName
		)
		BEGIN
			SET @ErrorDetail = 'Invalid property name provided. Property does not exist.'
			RAISERROR(@ErrorDetail, 16, 1);
			RETURN 0;
		END
	ELSE IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[Properties] WHERE [PropertyName] = @PropertyName AND [ValidTo] IS NULL
		)
		BEGIN
			SET @ErrorDetail = 'Property name provided does not have a current valid version of the required value.'
			RAISERROR(@ErrorDetail, 16, 1);
			RETURN 0;
		END
	--get valid property value
	ELSE
		BEGIN
			SELECT
				[PropertyValue]
			FROM
				[procfwk].[CurrentProperties]
			WHERE
				[PropertyName] = @PropertyName
		END
END;
GO
PRINT N'Creating [procfwk].[UpdateExecutionLog]...';


GO
CREATE PROCEDURE [procfwk].[UpdateExecutionLog]
	(
	@PerformErrorCheck BIT = 1
	)
AS
BEGIN
	SET NOCOUNT ON;
		
	DECLARE @AllCount INT
	DECLARE @SuccessCount INT

	IF @PerformErrorCheck = 1
	BEGIN
		--Check current execution
		SELECT @AllCount = COUNT(0) FROM [procfwk].[CurrentExecution]
		SELECT @SuccessCount = COUNT(0) FROM [procfwk].[CurrentExecution] WHERE [PipelineStatus] = 'Success'

		IF @AllCount <> @SuccessCount
			BEGIN
				RAISERROR('Framework execution complete but not all Worker pipelines succeeded. See the [procfwk].[CurrentExecution] table for details',16,1);
				RETURN 0;
			END;
	END;

	--Do this if no error raised and when called by the execution wrapper (OverideRestart = 1).
	INSERT INTO [procfwk].[ExecutionLog]
		(
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
		)
	SELECT
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
	FROM
		[procfwk].[CurrentExecution];

	TRUNCATE TABLE [procfwk].[CurrentExecution];
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineSuccess]...';


GO
CREATE PROCEDURE procfwk.SetLogPipelineSuccess
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[PipelineStatus] = 'Success',
		[EndDateTime] = GETUTCDATE()
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineRunning]...';


GO
CREATE PROCEDURE procfwk.SetLogPipelineRunning
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[StartDateTime] = GETUTCDATE(),
		[PipelineStatus] = 'Running'
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId
END;
GO
PRINT N'Creating [procfwk].[SetLogStagePreparing]...';


GO
CREATE PROCEDURE [procfwk].[SetLogStagePreparing]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT
	)
AS
BEGIN
	SET NOCOUNT ON;
	
	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[PipelineStatus] = 'Preparing'
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [StartDateTime] IS NULL
		AND [IsBlocked] <> 1;
END;
GO
PRINT N'Creating [procfwk].[CreateNewExecution]...';


GO
CREATE PROCEDURE [procfwk].[CreateNewExecution]
	(
	@CallingDataFactoryName NVARCHAR(200)
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @LocalExecutionId UNIQUEIDENTIFIER = NEWID()

	TRUNCATE TABLE [procfwk].[CurrentExecution];

	INSERT INTO [procfwk].[CurrentExecution]
		(
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName]
		)
	SELECT
		@LocalExecutionId,
		p.[StageId],
		p.[PipelineId],
		@CallingDataFactoryName,
		d.[ResourceGroupName],
		d.[DataFactoryName],
		p.[PipelineName]
	FROM
		[procfwk].[Pipelines] p
		INNER JOIN [procfwk].[Stages] s
			ON p.[StageId] = s.[StageId]
		INNER JOIN [procfwk].[DataFactorys] d
			ON p.[DataFactoryId] = d.[DataFactoryId]
	WHERE
		p.[Enabled] = 1
		AND s.[Enabled] = 1

	ALTER INDEX [IDX_GetPipelinesInStage] ON [procfwk].[CurrentExecution]
	REBUILD;

	SELECT
		@LocalExecutionId AS ExecutionId
END;
GO
PRINT N'Creating [procfwk].[GetPipelineParameters]...';


GO
CREATE PROCEDURE [procfwk].[GetPipelineParameters]
	(
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @Json VARCHAR(MAX) = ''

	--get parameters if required for worker pipeline
	IF NOT EXISTS
		(
		SELECT 
			[ParameterId] 
		FROM 
			[procfwk].[PipelineParameters] 
		WHERE 
			[PipelineId] = @PipelineId
		)
		BEGIN
			SET @Json = '' --Can't return NULL. Would break ADF expression.
		END
	ELSE
		BEGIN
			SELECT
				@Json += 
						CASE
							WHEN [ParameterValue] IS NULL THEN '' --don't add pair so ADF uses default
							ELSE '"' + [ParameterName] + '": "' + STRING_ESCAPE([ParameterValue],'json') + '",'
						END
			FROM
				[procfwk].[PipelineParameters]
			WHERE
				[PipelineId] = @PipelineId;
			
			--handle parameter(s) with a NULL values
			IF LEN(@Json) > 0
			BEGIN
				--JSON snippet gets injected into Azure Function body request via Data Factory expressions.
				--Comma used to support Data Factory expression.
				SET @Json = ',"pipelineParameters": {' + LEFT(@Json,LEN(@Json)-1) + '}'

				--update current execution log if this is a runtime request
				UPDATE
					[procfwk].[CurrentExecution]
				SET
					--add extra braces to make JSON string valid in logs
					[PipelineParamsUsed] = '{ ' + RIGHT(@Json,LEN(@Json)-1) + ' }'
				WHERE
				[PipelineId] = @PipelineId;
			END;
		END;

	--return JSON snippet
	SELECT @Json AS Params
END;
GO
PRINT N'Creating [procfwk].[GetPipelinesInStage]...';


GO
CREATE PROCEDURE procfwk.GetPipelinesInStage
	(
	@StageId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	SELECT 
		[PipelineId], 
		[PipelineName],
		[DataFactoryName],
		[ResourceGroupName]
	FROM 
		[procfwk].[CurrentExecution]
	WHERE 
		[StageId] = @StageId
		AND ISNULL([PipelineStatus],'') <> 'Success'
		AND [IsBlocked] <> 1
	ORDER BY
		[PipelineId] ASC;
END;
GO
PRINT N'Creating [procfwk].[GetStages]...';


GO
CREATE   PROCEDURE [procfwk].[GetStages]
	(
	@ExecutionId UNIQUEIDENTIFIER
	)
AS
BEGIN
	SET NOCOUNT ON;

	SELECT DISTINCT 
		[StageId] 
	FROM 
		[procfwk].[CurrentExecution]
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND ISNULL([PipelineStatus],'') <> 'Success'
	ORDER BY 
		[StageId] ASC
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineChecking]...';


GO
CREATE PROCEDURE [procfwk].[SetLogPipelineChecking]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[PipelineStatus] = 'Checking'
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId
END;
GO
PRINT N'Creating [procfwk].[GetEmailAlertParts]...';


GO
CREATE PROCEDURE [procfwk].[GetEmailAlertParts]
	(
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ToRecipients NVARCHAR(MAX) = ''
	DECLARE @CcRecipients NVARCHAR(MAX) = ''
	DECLARE @BccRecipients NVARCHAR(MAX) = ''
	DECLARE @EmailSubject NVARCHAR(500)
	DECLARE	@EmailBody NVARCHAR(MAX)
	DECLARE @EmailImportance VARCHAR(5)
	DECLARE @OutcomeBitValue INT

	--map pipeline status to alert outcome bit value
	SELECT
		@OutcomeBitValue = ao.[BitValue]
	FROM
		[procfwk].[CurrentExecution] ce
		INNER JOIN [procfwk].[AlertOutcomes] ao
			ON ce.[PipelineStatus] = ao.[PipelineOutcomeStatus]
	WHERE
		ce.[PipelineId] = @PipelineId;

	--get to recipients
	SELECT
		@ToRecipients += r.[EmailAddress] + ','
	FROM
		[procfwk].[PipelineAlertLink] al
		INNER JOIN [procfwk].[Recipients] r
			ON al.[RecipientId] = r.[RecipientId]
	WHERE
		al.[PipelineId] = @PipelineId
		AND al.[Enabled] = 1
		AND r.[Enabled] = 1
		AND UPPER(r.[MessagePreference]) = 'TO'
		AND (
			al.[OutcomesBitValue] & @OutcomeBitValue <> 0
			OR al.[OutcomesBitValue] & 1 <> 0 --all
			);

	IF (@ToRecipients <> '') SET @ToRecipients = LEFT(@ToRecipients,LEN(@ToRecipients)-1);

	--get cc recipients
	SELECT
		@CcRecipients += r.[EmailAddress] + ','
	FROM
		[procfwk].[PipelineAlertLink] al
		INNER JOIN [procfwk].[Recipients] r
			ON al.[RecipientId] = r.[RecipientId]
	WHERE
		al.[PipelineId] = @PipelineId
		AND al.[Enabled] = 1
		AND r.[Enabled] = 1
		AND UPPER(r.[MessagePreference]) = 'CC'
		AND (
			al.[OutcomesBitValue] & @OutcomeBitValue <> 0
			OR al.[OutcomesBitValue] & 1 <> 0 --all
			);
	
	IF (@CcRecipients <> '') SET @CcRecipients = LEFT(@CcRecipients,LEN(@CcRecipients)-1);

	--get bcc recipients
	SELECT
		@BccRecipients += r.[EmailAddress] + ','
	FROM
		[procfwk].[PipelineAlertLink] al
		INNER JOIN [procfwk].[Recipients] r
			ON al.[RecipientId] = r.[RecipientId]
	WHERE
		al.[PipelineId] = @PipelineId
		AND al.[Enabled] = 1
		AND r.[Enabled] = 1
		AND UPPER(r.[MessagePreference]) = 'BCC'
		AND (
			al.[OutcomesBitValue] & @OutcomeBitValue <> 0
			OR al.[OutcomesBitValue] & 1 <> 0 --all
			);

	IF (@BccRecipients <> '') SET @BccRecipients = LEFT(@BccRecipients,LEN(@BccRecipients)-1);
	
	--get email template
	SELECT
		@EmailBody = [PropertyValue]
	FROM
		[procfwk].[CurrentProperties]
	WHERE
		[PropertyName] = 'EmailAlertBodyTemplate';

	--set subject, body and importance
	SELECT TOP (1)
		--subject
		@EmailSubject = 'ADFprocfwk Alert: ' + [PipelineName] + ' - ' + [PipelineStatus],
	
		--body
		@EmailBody = REPLACE(@EmailBody,'##PipelineName###',[PipelineName]),
		@EmailBody = REPLACE(@EmailBody,'##Status###',[PipelineStatus]),
		@EmailBody = REPLACE(@EmailBody,'##ExecId###',CAST([LocalExecutionId] AS VARCHAR(36))),
		@EmailBody = REPLACE(@EmailBody,'##RunId###',CAST([AdfPipelineRunId] AS VARCHAR(36))),
		@EmailBody = REPLACE(@EmailBody,'##StartDateTime###',CONVERT(VARCHAR(30), [StartDateTime], 120)),
		@EmailBody = CASE
						WHEN [EndDateTime] IS NULL THEN REPLACE(@EmailBody,'##EndDateTime###','N/A')
						ELSE REPLACE(@EmailBody,'##EndDateTime###',CONVERT(VARCHAR(30), [EndDateTime], 120))
					END,
		@EmailBody = CASE
						WHEN [EndDateTime] IS NULL THEN REPLACE(@EmailBody,'##Duration###','N/A')
						ELSE REPLACE(@EmailBody,'##Duration###',CAST(DATEDIFF(MINUTE, [StartDateTime], [EndDateTime]) AS VARCHAR(30)))
					END,
		@EmailBody = REPLACE(@EmailBody,'##CalledByADF###',[CallingDataFactoryName]),
		@EmailBody = REPLACE(@EmailBody,'##ExecutedByADF###',[DataFactoryName]),

		--importance
		@EmailImportance = 
			CASE [PipelineStatus] 
				WHEN 'Success' THEN 'Low'
				WHEN 'Failed' THEN 'High'
				ELSE 'Normal'
			END
	FROM
		[procfwk].[CurrentExecution]
	WHERE
		[PipelineId] = @PipelineId
	ORDER BY
		[StartDateTime] DESC;
	
	--precaution
	IF @EmailBody IS NULL
		SET @EmailBody = 'Internal error. Failed to create profwk email alert body. Execute procedure [procfwk].[GetEmailAlertParts] with pipeline Id: ' + CAST(@PipelineId AS VARCHAR(30)) + ' to debug.';

	--return email parts
	SELECT
		@ToRecipients AS emailRecipients,
		@CcRecipients AS emailCcRecipients,
		@BccRecipients AS emailBccRecipients,
		@EmailSubject AS emailSubject,
		@EmailBody AS emailBody,
		@EmailImportance AS emailImportance;
END;
GO
PRINT N'Creating [procfwk].[CheckForEmailAlerts]...';


GO
CREATE PROCEDURE [procfwk].[CheckForEmailAlerts]
	(
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @SendAlerts BIT
	DECLARE @AlertingEnabled BIT

	--get property
	SELECT
		@AlertingEnabled = [procfwk].[GetPropertyValueInternal]('UseFrameworkEmailAlerting');

	--based on global property
	IF (@AlertingEnabled = 1)
		BEGIN
			--based on piplines to recipients link
			IF EXISTS
				(
				SELECT pal.AlertId
				FROM procfwk.CurrentExecution AS ce
				INNER JOIN procfwk.AlertOutcomes AS ao
					ON ao.PipelineOutcomeStatus = ce.PipelineStatus
				INNER JOIN procfwk.PipelineAlertLink AS pal
					ON pal.PipelineId = ce.PipelineId
				INNER JOIN procfwk.Recipients AS r
					ON r.RecipientId = pal.RecipientId
				WHERE ce.PipelineId = @PipelineId
					  AND ao.BitValue & pal.OutcomesBitValue > 0
					  AND pal.[Enabled] = 1
					  AND r.[Enabled] = 1
				)
				BEGIN
					SET @SendAlerts = 1;
				END;
			ELSE
				BEGIN
					SET @SendAlerts = 0;
				END;
		END
	ELSE
		BEGIN
			SET @SendAlerts = 0;
		END;

	SELECT @SendAlerts AS SendAlerts
END;
GO
PRINT N'Creating [procfwk].[SetErrorLogDetails]...';


GO
CREATE PROCEDURE [procfwk].[SetErrorLogDetails]
	(
	@LocalExecutionId UNIQUEIDENTIFIER,
	@JsonErrorDetails VARCHAR(MAX)
	)
AS
BEGIN
	SET NOCOUNT ON;

	INSERT INTO [procfwk].[ErrorLog]
		(
		[LocalExecutionId],
		[AdfPipelineRunId],
		[ActivityRunId],
		[ActivityName],
		[ActivityType],
		[ErrorCode],
		[ErrorType],
		[ErrorMessage]
		)
	SELECT
		@LocalExecutionId,
		Base.[RunId],
		ErrorDetail.[ActivityRunId],
		ErrorDetail.[ActivityName],
		ErrorDetail.[ActivityType],
		ErrorDetail.[ErrorCode],
		ErrorDetail.[ErrorType],
		ErrorDetail.[ErrorMessage]
	FROM 
		OPENJSON(@JsonErrorDetails) WITH
			( 
			[RunId] UNIQUEIDENTIFIER,
			[Errors] NVARCHAR(MAX) AS JSON
			) AS Base
		CROSS APPLY OPENJSON (Base.[Errors]) WITH
			(
			[ActivityRunId] UNIQUEIDENTIFIER,
			[ActivityName] VARCHAR(100),
			[ActivityType] VARCHAR(100),
			[ErrorCode] VARCHAR(100),
			[ErrorType] VARCHAR(100),
			[ErrorMessage] VARCHAR(MAX)
			) AS ErrorDetail
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineRunId]...';


GO
CREATE PROCEDURE [procfwk].[SetLogPipelineRunId]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT,
	@RunId UNIQUEIDENTIFIER = NULL
	)
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[AdfPipelineRunId] = @RunId
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineLastStatusCheck]...';


GO
CREATE PROCEDURE [procfwk].[SetLogPipelineLastStatusCheck]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[LastStatusCheckDateTime] = GETUTCDATE()
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId
END;
GO
PRINT N'Creating [procfwk].[CheckMetadataIntegrity]...';


GO
CREATE PROCEDURE [procfwk].[CheckMetadataIntegrity]
	(
	@DebugMode BIT = 0
	)
AS
BEGIN
	SET NOCOUNT ON;
	
	/*
	Check 1 - Are there execution stages enabled in the metadata?
	Check 2 - Are there pipelines enabled in the metadata?
	Check 3 - Are there any service principals available to run the processing pipelines?
	Check 4 - Is there a current TenantId property available?
	Check 5 - Is there a current SubscriptionId property available?
	Check 6 - Is there a current OverideRestart property available?
	Check 7 - Are there any enabled pipelines configured without a service principal?
	Check 8 - Does the TenantId property still have its default value?
	Check 9 - Does the SubscriptionId property still have its default value?
	Check 10 - Is there a current PipelineStatusCheckDuration property available?
	Check 11 - Is there a current UseFrameworkEmailAlerting property available?
	Check 12 - Is there a current EmailAlertBodyTemplate property available?
	Check 13 - Does the total size of the request body for the pipeline parameters added exceed the Azure Functions size limit when the Worker execute pipeline body is created?
	Check 14 - Is there a current FailureHandling property available?
	Check 15 - Does the FailureHandling property have a valid value?
	Check 16 - When using DependencyChain failure handling, are there any dependants in the same execution stage of the predecessor?
	Check 17 - Does the SPNHandlingMethod property have a valid value?
	Check 18 - Does the Service Principal table contain both types of SPN handling for a single credential?
	---------------------------------------------------------------------------------------------------------------------------------
	Check A: - Are there any Running pipelines that need to be cleaned up?
	*/

	DECLARE @ErrorDetails VARCHAR(500)
	DECLARE @MetadataIntegrityIssues TABLE
		(
		[CheckNumber] INT NOT NULL,
		[IssuesFound] VARCHAR(MAX) NOT NULL
		)

	/*
	Checks:
	*/

	--Check 1:
	IF NOT EXISTS
		(
		SELECT 1 FROM [procfwk].[Stages] WHERE [Enabled] = 1
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				1,
				'No execution stages are enabled within the metadatabase. Data Factory has nothing to run.'
				)
		END;

	--Check 2:
	IF NOT EXISTS
		(
		SELECT 1 FROM [procfwk].[Pipelines] WHERE [Enabled] = 1
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				2,
				'No execution pipelines are enabled within the metadatabase. Data Factory has nothing to run.'
				)
		END;

	--Check 3:
	IF NOT EXISTS 
		(
		SELECT 1 FROM [dbo].[ServicePrincipals]
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				3,
				'No service principal details have been added to the metadata. Data Factory cannot authorise pipeline executions.'
				)		
		END;

	--Check 4:
	IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[CurrentProperties] WHERE [PropertyName] = 'TenantId'
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				4,
				'A current TenantId value is missing from the properties table.'
				)		
		END;

	--Check 5:
	IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[CurrentProperties] WHERE [PropertyName] = 'SubscriptionId'
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				5,
				'A current SubscriptionId value is missing from the properties table.'
				)		
		END;

	--Check 6:
	IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[CurrentProperties] WHERE [PropertyName] = 'OverideRestart'
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				6,
				'A current OverideRestart value is missing from the properties table.'
				)		
		END;

	--Check 7:
	IF EXISTS
		( 
		SELECT 
			* 
		FROM 
			[procfwk].[Pipelines] p 
			LEFT OUTER JOIN [procfwk].[PipelineAuthLink] al 
				ON p.[PipelineId] = al.[PipelineId]
		WHERE
			p.[Enabled] = 1
			AND al.[PipelineId] IS NULL
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				7,
				'Enabled pipelines are missing a valid Service Principal link.'
				)		
		END;

	--Check 8:
	IF ([procfwk].[GetPropertyValueInternal]('TenantId')) = '1234-1234-1234-1234-1234'
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				8,
				'Tenant Id property is still set to its default value of 1234-1234-1234-1234-1234.'
				)		
		END;

	--Check 9:
	IF ([procfwk].[GetPropertyValueInternal]('SubscriptionId')) = '1234-1234-1234-1234-1234'
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				9,
				'Subscription Id property is still set to its default value of 1234-1234-1234-1234-1234.'
				)		
		END;

	--Check 10:
	IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[CurrentProperties] WHERE [PropertyName] = 'PipelineStatusCheckDuration'
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				10,
				'A current PipelineStatusCheckDuration value is missing from the properties table.'
				)		
		END;

	--Check 11:
	IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[CurrentProperties] WHERE [PropertyName] = 'UseFrameworkEmailAlerting'
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				11,
				'A current UseFrameworkEmailAlerting value is missing from the properties table.'
				)		
		END;

	--Check 12:
	IF (
		SELECT
			[PropertyValue]
		FROM
			[procfwk].[CurrentProperties]
		WHERE
			[PropertyName] = 'UseFrameworkEmailAlerting'
		) = 1
		BEGIN
			IF NOT EXISTS
				(
				SELECT * FROM [procfwk].[CurrentProperties] WHERE [PropertyName] = 'EmailAlertBodyTemplate'
				)
				BEGIN
					INSERT INTO @MetadataIntegrityIssues
					VALUES
						( 
						12,
						'A current EmailAlertBodyTemplate value is missing from the properties table.'
						)		
				END;
		END;

	--Check 13:
	IF EXISTS
		(
		SELECT * FROM [procfwk].[PipelineParameterDataSizes] WHERE [Size] > 9
		/*
		Azure Function request limit is 10MB.
		https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale
		9MB to allow for other content in execute pipeline body request.
		*/
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				13,
				'The pipeline parameters entered exceed the Azure Function request body maximum of 10MB. Query view [procfwk].[PipelineParameterDataSizes] for details.'
				)	
		END;

	--Check 14:
	IF NOT EXISTS
		(
		SELECT * FROM [procfwk].[CurrentProperties] WHERE [PropertyName] = 'FailureHandling'
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				14,
				'A current FailureHandling value is missing from the properties table.'
				)		
		END;

	--Check 15:
	IF NOT EXISTS
		(
		SELECT 
			*
		FROM
			[procfwk].[CurrentProperties] 
		WHERE 
			[PropertyName] = 'FailureHandling' 
			AND [PropertyValue] IN ('None','Simple','DependencyChain')
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				15,
				'The property FailureHandling does not have a supported value.'
				)	
		END;

	--Check 16:
	IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'DependencyChain'
	BEGIN
		IF EXISTS
		(
		SELECT 
			pd.[DependencyId]
		FROM 
			[procfwk].[PipelineDependencies] pd
			INNER JOIN [procfwk].[Pipelines] pp
				ON pd.[PipelineId] = pp.[PipelineId]
			INNER JOIN [procfwk].[Pipelines] dp
				ON pd.[DependantPipelineId] = dp.[PipelineId]
		WHERE
			pp.[StageId] = dp.[StageId]
		)	
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				16,
				'A dependant pipeline and its upstream predecessor exist in the same execution stage. Fix this dependency chain to allow correct failure handling.'
				)	
		END;
	END;

	--Check 17:
	IF NOT EXISTS
		(
		SELECT 
			*
		FROM
			[procfwk].[CurrentProperties] 
		WHERE 
			[PropertyName] = 'SPNHandlingMethod' 
			AND [PropertyValue] IN ('StoreInDatabase','StoreInKeyVault')
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				17,
				'The property SPNHandlingMethod does not have a supported value.'
				)	
		END;

	--Check 18:
	IF EXISTS
		(
		SELECT
			*
		FROM
			[dbo].[ServicePrincipals]
		WHERE
			(
			[PrincipalId] IS NOT NULL
			OR [PrincipalSecret] IS NOT NULL
			)
			AND 
			(
			[PrincipalIdUrl] IS NOT NULL
			OR [PrincipalSecretUrl] IS NOT NULL
			)
		)
		BEGIN
			INSERT INTO @MetadataIntegrityIssues
			VALUES
				( 
				18,
				'The table [dbo].[ServicePrincipals] can only have one method of SPN details sorted per credential ID.'
				)	
		END;

	/*
	Integrity Checks Outcome:
	*/
	
	--throw runtime error if checks fail
	IF EXISTS
		(
		SELECT * FROM @MetadataIntegrityIssues
		)
		AND @DebugMode = 0
		BEGIN
			SET @ErrorDetails = 'Metadata integrity checks failed. Run EXEC [procfwk].[CheckMetadataIntegrity] @DebugMode = 1; for details.'

			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
		END;

	/*
	Previous Exeuction Checks:
	*/
	
	--Check A:
	IF EXISTS
		(
		SELECT [LocalExecutionId] FROM [procfwk].[CurrentExecution] WHERE [PipelineStatus] NOT IN ('Success','Failed','Blocked') AND [AdfPipelineRunId] IS NOT NULL
		)
		BEGIN
			--return pipelines details that require a clean up
			SELECT 
				[procfwk].[GetPropertyValueInternal]('TenantId') AS TenantId,
				[procfwk].[GetPropertyValueInternal]('SubscriptionId') AS SubscriptionId,
				[ResourceGroupName],
				[DataFactoryName],
				[PipelineName],
				[AdfPipelineRunId],
				[LocalExecutionId],
				[StageId],
				[PipelineId]
			FROM 
				[procfwk].[CurrentExecution]
			WHERE 
				[PipelineStatus] NOT IN ('Success','Failed','Blocked','Cancelled') 
				AND [AdfPipelineRunId] IS NOT NULL
		END;
	ELSE
		BEGIN
			--lookup activity must return something, even if just an empty dataset
			SELECT 
				NULL AS TenantId,
				NULL AS SubscriptionId,
				NULL AS ResourceGroupName,
				NULL AS DataFactoryName,
				NULL AS PipelineName,
				NULL AS AdfPipelineRunId,
				NULL AS LocalExecutionId,
				NULL AS StageId,
				NULL AS PipelineId
			FROM
				[procfwk].[CurrentExecution]
			WHERE
				1 = 2; --ensure no results
		END;

	--report issues when in debug mode
	IF @DebugMode = 1
	BEGIN
		IF NOT EXISTS
			(
			SELECT * FROM @MetadataIntegrityIssues
			)
			BEGIN
				PRINT 'No data integrity issues found in metadata.'
			END
		ELSE		
			BEGIN
				SELECT * FROM @MetadataIntegrityIssues;
			END;
	END;
END;
GO
PRINT N'Creating [procfwk].[ResetExecution]...';


GO
CREATE PROCEDURE [procfwk].[ResetExecution]
AS
BEGIN 
	
	--capture any pipelines that may have been cancelled
	INSERT INTO [procfwk].[ExecutionLog]
		(
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime]
		)
	SELECT
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[PipelineName],
		[StartDateTime],
		'Cancelled', --assumption that this is what happened
		[EndDateTime]
	FROM
		[procfwk].[CurrentExecution]
	WHERE
		--these are predicted states so aren't considered cancellations
		[PipelineStatus] NOT IN
			(
			'Success',
			'Failed',
			'Blocked'
			)
		
	--reset status ready for next attempt
	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[StartDateTime] = NULL,
		[EndDateTime] = NULL,
		[PipelineStatus] = NULL,
		[LastStatusCheckDateTime] = NULL,
		[AdfPipelineRunId] = NULL,
		[PipelineParamsUsed] = NULL,
		[IsBlocked] = 0
	WHERE
		ISNULL([PipelineStatus],'') <> 'Success'
		OR [IsBlocked] = 1
	
	--return current execution id
	SELECT DISTINCT
		[LocalExecutionId] AS ExecutionId
	FROM
		[procfwk].[CurrentExecution]

END
GO
PRINT N'Creating [procfwk].[SetExecutionBlockDependants]...';


GO
CREATE PROCEDURE [procfwk].[SetExecutionBlockDependants]
	(
	@ExecutionId UNIQUEIDENTIFIER = NULL,
	@PipelineId INT
	)
AS
BEGIN
	--assume current execution if value not provided
	IF @ExecutionId IS NULL SELECT TOP 1 @ExecutionId = [LocalExecutionId] FROM [procfwk].[CurrentExecution];
	
	--update dependents status
	UPDATE
		ce
	SET
		ce.[PipelineStatus] = 'Blocked',
		ce.[IsBlocked] = 1
	FROM
		[procfwk].[PipelineDependencies] pe
		INNER JOIN [procfwk].[CurrentExecution] ce
			ON pe.[DependantPipelineId] = ce.[PipelineId]
	WHERE
		ce.[LocalExecutionId] = @ExecutionId
		AND pe.[PipelineId] = @PipelineId
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineCancelled]...';


GO
CREATE PROCEDURE [procfwk].[SetLogPipelineCancelled]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ErrorDetail VARCHAR(500);

	--mark specific failure pipeline
	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[PipelineStatus] = 'Cancelled'
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId

	--persist cancelled pipeline records to long term log
	INSERT INTO [procfwk].[ExecutionLog]
		(
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
		)
	SELECT
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
	FROM
		[procfwk].[CurrentExecution]
	WHERE
		[PipelineStatus] = 'Cancelled'
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId;

	--block down stream stages?
	IF ([procfwk].[GetPropertyValueInternal]('CancelledWorkerResultBlocks')) = 1
	BEGIN	
		--decide how to proceed with error/failure depending on framework property configuration
		IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'None'
			BEGIN
				--do nothing allow processing to carry on regardless
				RETURN 0;
			END;

		ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'Simple'
			BEGIN
				--flag all downstream stages as blocked
				UPDATE
					[procfwk].[CurrentExecution]
				SET
					[PipelineStatus] = 'Blocked',
					[IsBlocked] = 1
				WHERE
					[LocalExecutionId] = @ExecutionId
					AND [StageId] > @StageId

				SET @ErrorDetail = 'Pipeline execution has a cancelled status. Blocking downstream stages as a precaution.'

				RAISERROR(@ErrorDetail,16,1);
				RETURN 0;
			END;
		ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'DependencyChain'
			BEGIN
				EXEC [procfwk].[SetExecutionBlockDependants]
					@ExecutionId = @ExecutionId,
					@PipelineId = @PipelineId
			END;
		ELSE
			BEGIN
				RAISERROR('Cancelled execution failure handling state.',16,1);
				RETURN 0;
			END;
	END;
END;
GO
PRINT N'Creating [procfwk].[ExecutePrecursorProcedure]...';


GO
CREATE PROCEDURE [procfwk].[ExecutePrecursorProcedure]
AS
BEGIN
	DECLARE @SQL VARCHAR(MAX) 
	DECLARE @ErrorDetail NVARCHAR(MAX)

	IF OBJECT_ID([procfwk].[GetPropertyValueInternal]('ExecutionPrecursorProc')) IS NOT NULL
		BEGIN
			BEGIN TRY
				SET @SQL = [procfwk].[GetPropertyValueInternal]('ExecutionPrecursorProc');
				EXEC(@SQL);
			END TRY
			BEGIN CATCH
				SELECT
					@ErrorDetail = 'Precursor procedure failed with error: ' + ERROR_MESSAGE();

				RAISERROR(@ErrorDetail,16,1);
			END CATCH
		END;
	ELSE
		BEGIN
			PRINT 'Precursor object not found in database.';
		END;
END;
GO
PRINT N'Creating [procfwkTesting].[Add300WorkerPipelines]...';


GO
CREATE PROCEDURE [procfwkTesting].[Add300WorkerPipelines]
AS
BEGIN

	--clear the decks from dev metadata
	DELETE FROM [procfwk].[PipelineDependencies];
	DBCC CHECKIDENT ('[procfwk].[PipelineDependencies]', RESEED, 0);

	DELETE FROM [procfwk].[PipelineAlertLink];
	DBCC CHECKIDENT ('[procfwk].[PipelineAlertLink]', RESEED, 0);

	DELETE FROM [procfwk].[Recipients];
	DBCC CHECKIDENT ('[procfwk].[Recipients]', RESEED, 0);

	DELETE FROM [procfwk].[PipelineAuthLink];
	DBCC CHECKIDENT ('[procfwk].[PipelineAuthLink]', RESEED, 0);

	DELETE FROM [dbo].[ServicePrincipals];
	DBCC CHECKIDENT ('[dbo].[ServicePrincipals]', RESEED, 0);

	DELETE FROM [procfwk].[PipelineParameters];
	DBCC CHECKIDENT ('[procfwk].[PipelineParameters]', RESEED, 0);

	DELETE FROM [procfwk].[Pipelines];
	DBCC CHECKIDENT ('[procfwk].[Pipelines]', RESEED, 0);

	--get data factory id
	DECLARE @ADFId INT
	
	SELECT 
		@ADFId = [DataFactoryId] 
	FROM 
		[procfwk].[DataFactorys] 
	WHERE 
		[DataFactoryName] = 'WorkersFactory';

	--insert 300 pipelines
	;WITH cte AS
		(
		SELECT TOP 300
			ROW_NUMBER() OVER (ORDER BY s1.[object_id]) AS 'Number'
		FROM 
			sys.all_columns AS s1
			CROSS JOIN sys.all_columns AS s2
		)
	INSERT INTO [procfwk].[Pipelines]
		(
		[DataFactoryId],
		[StageId],
		[PipelineName],
		[LogicalPredecessorId],
		[Enabled]
		)
	SELECT
		@ADFId,
		CASE
			WHEN [Number] <= 100 THEN 1
			WHEN [Number] > 100 AND  [Number] <= 200 THEN 2
			WHEN [Number] > 200 AND  [Number] <= 300 THEN 3
		END,
		'Wait ' + CAST([Number] AS VARCHAR),
		NULL,
		1
	FROM
		cte;

	--disable other execution stages if exist
	UPDATE [procfwk].[Stages] SET [Enabled] = 0 WHERE [StageId] > 3;

	--insert 300 pipeline parameters
	INSERT INTO [procfwk].[PipelineParameters]	
		(
		[PipelineId],
		[ParameterName],
		[ParameterValue]
		)
	SELECT
		[PipelineId],
		'WaitTime',
		LEFT(ABS(CAST(CAST(NEWID() AS VARBINARY) AS INT)),2)
	FROM
		[procfwk].[Pipelines];
END;
GO
PRINT N'Creating [procfwkHelpers].[GetExecutionDetails]...';


GO
CREATE PROCEDURE [procfwkHelpers].[GetExecutionDetails]
	(
	@LocalExecutionId UNIQUEIDENTIFIER = NULL
	)
AS
BEGIN

	--Get last execution ID
	IF @LocalExecutionId IS NULL
	BEGIN
		WITH maxLog AS
			(
			SELECT
				MAX([LogId]) AS MaxLogId
			FROM
				[procfwk].[ExecutionLog]
			)
		SELECT
			@LocalExecutionId = el1.[LocalExecutionId]
		FROM
			[procfwk].[ExecutionLog] el1
			INNER JOIN maxLog
				ON maxLog.[MaxLogId] = el1.[LogId];
	END;

	--Execution Summary
	SELECT
		CAST(el2.[StageId] AS VARCHAR(5)) + ' - ' + stgs.[StageName] AS Stage,
		COUNT(0) AS RecordCount,
		DATEDIFF(MINUTE, MIN(el2.[StartDateTime]), MAX(el2.[EndDateTime])) DurationMinutes
	FROM
		[procfwk].[ExecutionLog] el2
		INNER JOIN [procfwk].[Stages] stgs
			ON el2.[StageId] = stgs.[StageId]
	WHERE
		el2.[LocalExecutionId] = @LocalExecutionId
	GROUP BY
		CAST(el2.[StageId] AS VARCHAR(5)) + ' - ' + stgs.[StageName]
	ORDER BY
		CAST(el2.[StageId] AS VARCHAR(5)) + ' - ' + stgs.[StageName];

	--Full execution details
	SELECT
		el3.[LogId],
		el3.[LocalExecutionId],
		el3.[StageId],
		stgs.[StageName],
		el3.[PipelineId],
		el3.[PipelineName],
		el3.[StartDateTime],
		el3.[EndDateTime],
		ISNULL(DATEDIFF(MINUTE, el3.[StartDateTime], el3.[EndDateTime]),0) AS DurationMinutes,
		el3.[PipelineStatus],
		el3.[AdfPipelineRunId],
		el3.[PipelineParamsUsed],
		errLog.[ActivityRunId],
		errLog.[ActivityName],
		errLog.[ActivityType],
		errLog.[ErrorCode],
		errLog.[ErrorType],
		errLog.[ErrorMessage]
	FROM 
		[procfwk].[ExecutionLog] el3
		LEFT OUTER JOIN [procfwk].[ErrorLog] errLog
			ON el3.[LocalExecutionId] = errLog.[LocalExecutionId]
				AND el3.[AdfPipelineRunId] = errLog.[AdfPipelineRunId]
		INNER JOIN [procfwk].[Stages] stgs
			ON el3.[StageId] = stgs.[StageId]
	WHERE
		el3.[LocalExecutionId] = @LocalExecutionId
	ORDER BY
		el3.[PipelineId],
		el3.[StartDateTime];
END;
GO
PRINT N'Creating [procfwkHelpers].[DeleteServicePrincipal]...';


GO
CREATE PROCEDURE [procfwkHelpers].[DeleteServicePrincipal]
	(
	@DataFactory NVARCHAR(200),
	@PrincipalIdValue NVARCHAR(256),
	@SpecificPipelineName NVARCHAR(200) = NULL
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ErrorDetails NVARCHAR(500) = ''
	DECLARE @CredentialId INT

	--resolve principal Id or Url to credential Id
	IF ([procfwk].[GetPropertyValueInternal]('SPNHandlingMethod')) = 'StoreInDatabase'
		BEGIN
			--defensive checks
			BEGIN TRY
				DECLARE @LocalPrincipalId UNIQUEIDENTIFIER

				SELECT --assigned to variable just to supress output of SELECT
					@LocalPrincipalId = CAST(@PrincipalIdValue AS UNIQUEIDENTIFIER)
			END TRY
			BEGIN CATCH
					SET @ErrorDetails = 'Invalid @PrincipalId provided. The format must be a UNIQUEIDENTIFIER.'
					RAISERROR(@ErrorDetails, 16, 1);
					RETURN 0;
			END CATCH	
			
			--get cred id using principal id
			SELECT
				@CredentialId = [CredentialId]
			FROM
				[dbo].[ServicePrincipals]
			WHERE
				[PrincipalId] = @PrincipalIdValue
		END
	ELSE IF ([procfwk].[GetPropertyValueInternal]('SPNHandlingMethod')) = 'StoreInKeyVault'
		BEGIN
			--get cred id using principal id url
			SELECT
				@CredentialId = [CredentialId]
			FROM
				[dbo].[ServicePrincipals]
			WHERE
				[PrincipalIdUrl] = @PrincipalIdValue
		END;
	ELSE
		BEGIN
			RAISERROR('Unknown SPN deletion method.',16,1);
			RETURN 0;
		END;

	--secondary defensive checks
	IF NOT EXISTS
		(
		SELECT [DataFactoryName] FROM [procfwk].[DataFactorys] WHERE [DataFactoryName] = @DataFactory
		)
		BEGIN
			SET @ErrorDetails = 'Invalid Data Factory name. Please ensure the Data Factory metadata exists.'
			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
		END

	IF @CredentialId IS NULL
		BEGIN
			SET @ErrorDetails = 'Invalid Service Principal Id Value provided. Please ensure the Service Principal exists.'
			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
		END

	--delete SPN for specific pipeline
	IF @SpecificPipelineName IS NOT NULL
		BEGIN
			IF NOT EXISTS
				( 
				SELECT [PipelineName] FROM [procfwk].[Pipelines] WHERE [PipelineName] = @SpecificPipelineName
				)
				BEGIN
					SET @ErrorDetails = 'Invalid Pipeline name. Please ensure the Pipeline metadata exists.'
					RAISERROR(@ErrorDetails, 16, 1);
					RETURN 0;
				END
			
			--delete links
			DELETE
				L
			FROM
				[procfwk].[PipelineAuthLink] L
				INNER JOIN [procfwk].[Pipelines] P
					ON L.[PipelineId] = P.[PipelineId]
				INNER JOIN [procfwk].[DataFactorys] D
					ON P.[DataFactoryId] = D.[DataFactoryId]
						AND L.[DataFactoryId] = D.[DataFactoryId]
				INNER JOIN [dbo].[ServicePrincipals] S
					ON L.[CredentialId] = S.[CredentialId]
			WHERE
				P.[PipelineName] = @SpecificPipelineName
				AND D.[DataFactoryName] = @DataFactory
				AND S.[CredentialId] = @CredentialId;
		END
	ELSE
		BEGIN
			--delete links
			DELETE
				L
			FROM
				[procfwk].[PipelineAuthLink] L
				INNER JOIN [procfwk].[DataFactorys] D
					ON L.[DataFactoryId] = D.[DataFactoryId]
						AND L.[DataFactoryId] = D.[DataFactoryId]
				INNER JOIN [dbo].[ServicePrincipals] S
					ON L.[CredentialId] = S.[CredentialId]
			WHERE
				D.[DataFactoryName] = @DataFactory
				AND S.[CredentialId] = @CredentialId;
		END

	--finall, delete principal only if not still used by other pipelines
	DELETE 
		SP
	FROM 
		[dbo].[ServicePrincipals] SP
		LEFT OUTER JOIN [procfwk].[PipelineAuthLink] AL
			ON SP.[CredentialId] = AL.[CredentialId]
	WHERE 
		SP.[CredentialId] = @CredentialId
		AND AL.[CredentialId] IS NULL;
END;
GO
PRINT N'Creating [procfwkHelpers].[DeleteRecipientAlerts]...';


GO
CREATE PROCEDURE [procfwkHelpers].[DeleteRecipientAlerts]
	(
	@EmailAddress NVARCHAR(500),
	@SoftDeleteOnly BIT = 1
	)
AS
BEGIN
	SET NOCOUNT ON;

	--defensive check
	IF NOT EXISTS
		(
		SELECT [RecipientId] FROM [procfwk].[Recipients] WHERE [EmailAddress] = @EmailAddress
		)
		BEGIN
			RAISERROR('Recipient email address does not exists in [procfwk].[Recipients] table.',16,1);
			RETURN 0;
		END;

	--update/delete
	IF @SoftDeleteOnly = 1
		BEGIN
			--disable links
			UPDATE
				al
			SET
				al.[Enabled] = 0
			FROM
				[procfwk].[PipelineAlertLink] al
				INNER JOIN [procfwk].[Recipients] r
					ON al.[RecipientId] = r.[RecipientId]
			WHERE
				r.[EmailAddress] = @EmailAddress;
	
			--disable recipient(s)
			UPDATE
				[procfwk].[Recipients]
			SET
				[Enabled] = 0
			WHERE
				[EmailAddress] = @EmailAddress;

		END
	ELSE
		BEGIN
			--delete links
			DELETE		
				al
			FROM
				[procfwk].[PipelineAlertLink] al
				INNER JOIN [procfwk].[Recipients] r
					ON al.[RecipientId] = r.[RecipientId]
			WHERE
				r.[EmailAddress] = @EmailAddress;

			--delete recipient(s)
			DELETE FROM
				[procfwk].[Recipients]
			WHERE
				[EmailAddress] = @EmailAddress;
		END;
END;
GO
PRINT N'Creating [procfwkHelpers].[CheckStageAndPiplineIntegrity]...';


GO
CREATE PROCEDURE [procfwkHelpers].[CheckStageAndPiplineIntegrity]
AS

BEGIN

	DECLARE @TempCheckStageAndPiplineIntegrity TABLE
		(
		[ResourceGroupName] NVARCHAR(200) NOT NULL,
		[DataFactoryName] NVARCHAR(200) NOT NULL,
		[StageId] INT NOT NULL,
		[StageName] VARCHAR(225) NOT NULL,
		[PipelineId] INT NOT NULL,
		[PipelineName] NVARCHAR(200) NOT NULL,
		[Enabled] BIT NOT NULL,
		[SuccessorStageId] INT NULL,
		[SuccessorStage] VARCHAR(225) NULL,
		[SuccessorId] INT NULL,
		[SuccessorName] NVARCHAR(200) NULL,
		[Information] VARCHAR(92) NULL
		)	
	
	--get min execution stage
	;WITH firstStage AS
		(
		SELECT
			MIN([StageId]) AS firstStageId
		FROM
			[procfwk].[Stages]
		)
	--query metadata
	INSERT INTO @TempCheckStageAndPiplineIntegrity
	SELECT
		adf.[ResourceGroupName],
		adf.[DataFactoryName],	
		base.[StageId],
		baseStage.[StageName],
		base.[PipelineId],
		base.[PipelineName],
		base.[Enabled],
		preds.[StageId] AS SuccessorStageId,
		predsStage.[StageName] AS SuccessorStage,
		preds.[PipelineId] AS SuccessorId,
		preds.[PipelineName] AS SuccessorName,
		CASE
			WHEN preds.[StageId] > base.[StageId] +1 THEN 'Successor pipeline could be moved to an earlier stage.'
			WHEN preds.[StageId] = base.[StageId] THEN 'Dependency issue, predeccessor pipeline is currently running in the same stage as successor.'
			WHEN preds.[PipelineId] IS NOT NULL AND base.[Enabled] = 0 THEN 'Disabled pipeline has downstream successors.'
			WHEN preds.[PipelineId] IS NOT NULL AND baseStage.[Enabled] = 0 THEN 'Disabled stage has downstream successors.'
			WHEN base.[LogicalPredecessorId] IS NULL AND base.[StageId] <> firstStage.[firstStageId] THEN 'Pipeline could be moved to an earlier stage.'
			ELSE NULL
		END AS Information
	FROM 
		--get base pipeline details
		[procfwk].[Pipelines] base
		INNER JOIN [procfwk].[DataFactorys] adf
			ON base.[DataFactoryId] = adf.[DataFactoryId]
		INNER JOIN [procfwk].[Stages] baseStage
			ON base.[StageId] = baseStage.[StageId]	
		--get successor details
		LEFT OUTER JOIN [procfwk].[Pipelines] preds
			ON base.[PipelineId] = preds.[LogicalPredecessorId]
		LEFT OUTER JOIN [procfwk].[Stages] predsStage
			ON preds.[StageId] = predsStage.[StageId]
		--other details for checking
		CROSS JOIN firstStage

	--provide outcome
	IF EXISTS
		(
		SELECT [Information] FROM @TempCheckStageAndPiplineIntegrity
		)
		BEGIN
			SELECT * FROM @TempCheckStageAndPiplineIntegrity
		END
	ELSE
		BEGIN
			PRINT 'No pipeline integrity issues to report. Nice work! :-)'
		END
END;
GO
PRINT N'Creating [procfwkHelpers].[AddServicePrincipalUrls]...';


GO
CREATE PROCEDURE [procfwkHelpers].[AddServicePrincipalUrls]
	(
	@DataFactory NVARCHAR(200),
	@PrincipalIdUrl NVARCHAR(MAX),
	@PrincipalSecretUrl NVARCHAR(MAX),
	@SpecificPipelineName NVARCHAR(200) = NULL,
	@PrincipalName NVARCHAR(256) = NULL
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @ErrorDetails NVARCHAR(500) = ''
	DECLARE @CredentialId INT

	--defensive checks
	IF NOT EXISTS
		(
		SELECT [DataFactoryName] FROM [procfwk].[DataFactorys] WHERE [DataFactoryName] = @DataFactory
		)
		BEGIN
			SET @ErrorDetails = 'Invalid Data Factory name. Please ensure the Data Factory metadata exists before trying to add authentication for it.'
			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
		END
	
	IF EXISTS
		(
		SELECT
			*
		FROM
			[procfwk].[PipelineAuthLink] AL
			INNER JOIN [procfwk].[DataFactorys] DF
				ON AL.[DataFactoryId] = DF.[DataFactoryId]
			INNER JOIN [procfwk].[Pipelines] PP
				ON AL.[PipelineId] = PP.[PipelineId]
		WHERE
			DF.[DataFactoryName] = @DataFactory
			AND PP.[PipelineName] = @SpecificPipelineName
		)
		BEGIN
			SET @ErrorDetails = 'The provided Pipeline or Data Factory combination already have a Service Principal. Delete the existing record using the procedure [procfwk].[DeleteServicePrincipal].'
			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
		END
	
	IF ([procfwkHelpers].[CheckForValidURL](@PrincipalIdUrl)) = 0
	BEGIN
		SET @ErrorDetails = 'PrincipalIdUrl value is not in the expected format. . Please confirm the URL follows the structure https://{YourKeyVaultName}.vault.azure.net/secrets/{YourSecretName} and does not include the secret version guid.'
		PRINT @ErrorDetails;
	END

	IF ([procfwkHelpers].[CheckForValidURL](@PrincipalSecretUrl)) = 0
	BEGIN
		SET @ErrorDetails = 'PrincipalSecretUrl value is not in the expected format. Please confirm the URL follows the structure https://{YourKeyVaultName}.vault.azure.net/secrets/{YourSecretName} and does not include the secret version guid.'
		PRINT @ErrorDetails;		
	END

	--add SPN for specific pipeline
	IF @SpecificPipelineName IS NOT NULL
		BEGIN
			--secondary defensive check for pipeline optional param
			IF NOT EXISTS
				( 
				SELECT [PipelineName] FROM [procfwk].[Pipelines] WHERE [PipelineName] = @SpecificPipelineName
				)
				BEGIN
					SET @ErrorDetails = 'Invalid Pipeline name. Please ensure the Pipeline metadata exists before trying to add authentication for it.'
					RAISERROR(@ErrorDetails, 16, 1);
					RETURN 0;
				END
			
			--spn may already exist for other pipelines
			IF NOT EXISTS
				(				
				SELECT [PrincipalIdUrl] FROM [dbo].[ServicePrincipals] WHERE [PrincipalIdUrl] = @PrincipalIdUrl
				)
				BEGIN
					--add service principal
					INSERT INTO [dbo].[ServicePrincipals]
						( 
						[PrincipalName],
						[PrincipalIdUrl],
						[PrincipalSecretUrl]
						)
					SELECT
						ISNULL(@PrincipalName, 'Unknown'),
						@PrincipalIdUrl,
						@PrincipalSecretUrl

					SET @CredentialId = SCOPE_IDENTITY()
				END
			ELSE
				BEGIN
					SELECT @CredentialId = [CredentialId] FROM [dbo].[ServicePrincipals] WHERE [PrincipalIdUrl] = @PrincipalIdUrl
				END

			--add single pipeline to SPN link
			INSERT INTO [procfwk].[PipelineAuthLink]
				(
				[PipelineId],
				[DataFactoryId],
				[CredentialId]
				)
			SELECT
				P.[PipelineId],
				D.[DataFactoryId],
				@CredentialId
			FROM
				[procfwk].[Pipelines] P
				INNER JOIN [procfwk].[DataFactorys] D
					ON P.[DataFactoryId] = D.[DataFactoryId]
			WHERE
				P.[PipelineName] = @SpecificPipelineName
				AND D.[DataFactoryName] = @DataFactory;
		END
	ELSE
		--add SPN for all pipelines in data factory
		BEGIN
			--add service principal
			INSERT INTO [dbo].[ServicePrincipals]
				( 
				[PrincipalName],
				[PrincipalIdUrl],
				[PrincipalSecretUrl]
				)
			SELECT
				ISNULL(@PrincipalName, 'Unknown'),
				@PrincipalIdUrl,
				@PrincipalSecretUrl

			SET @CredentialId = SCOPE_IDENTITY()

			--add link
			INSERT INTO [procfwk].[PipelineAuthLink]
				(
				[PipelineId],
				[DataFactoryId],
				[CredentialId]
				)
			SELECT
				P.[PipelineId],
				D.[DataFactoryId],
				@CredentialId
			FROM
				[procfwk].[Pipelines] P
				INNER JOIN [procfwk].[DataFactorys] D
					ON P.[DataFactoryId] = D.[DataFactoryId]
				LEFT OUTER JOIN [procfwk].[PipelineAuthLink] L
					ON P.[PipelineId] = L.[PipelineId]
			WHERE
				D.[DataFactoryName] = @DataFactory
				AND L.[PipelineId] IS NULL;
		END
END;
GO
PRINT N'Creating [procfwkHelpers].[AddServicePrincipal]...';


GO
CREATE PROCEDURE [procfwkHelpers].[AddServicePrincipal]
	(
	@DataFactory NVARCHAR(200),
	@PrincipalId NVARCHAR(256),
	@PrincipalSecret NVARCHAR(MAX),
	@SpecificPipelineName NVARCHAR(200) = NULL,
	@PrincipalName NVARCHAR(256) = NULL
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @ErrorDetails NVARCHAR(500) = ''
	DECLARE @CredentialId INT
	DECLARE @TenantId CHAR(36)
	DECLARE @LocalPrincipalId UNIQUEIDENTIFIER

	--defensive checks
	BEGIN TRY
		SELECT --assigned to variable just to supress output of SELECT
			@LocalPrincipalId = CAST(@PrincipalId AS UNIQUEIDENTIFIER)
	END TRY
	BEGIN CATCH
			SET @ErrorDetails = 'Invalid @PrincipalId provided. The format must be a UNIQUEIDENTIFIER.'
			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
	END CATCH

	IF NOT EXISTS
		(
		SELECT [DataFactoryName] FROM [procfwk].[DataFactorys] WHERE [DataFactoryName] = @DataFactory
		)
		BEGIN
			SET @ErrorDetails = 'Invalid Data Factory name. Please ensure the Data Factory metadata exists before trying to add authentication for it.'
			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
		END
	
	IF EXISTS
		(
		SELECT
			*
		FROM
			[procfwk].[PipelineAuthLink] AL
			INNER JOIN [procfwk].[DataFactorys] DF
				ON AL.[DataFactoryId] = DF.[DataFactoryId]
			INNER JOIN [procfwk].[Pipelines] PP
				ON AL.[PipelineId] = PP.[PipelineId]
		WHERE
			DF.[DataFactoryName] = @DataFactory
			AND PP.[PipelineName] = @SpecificPipelineName
		)
		BEGIN
			SET @ErrorDetails = 'The provided Pipeline or Data Factory combination already have a Service Principal. Delete the existing record using the procedure [procfwk].[DeleteServicePrincipal].'
			RAISERROR(@ErrorDetails, 16, 1);
			RETURN 0;
		END
	
	--get tenant Id to include in encryption
	SELECT
		@TenantId = [procfwk].[GetPropertyValueInternal]('TenantId');
		
	--add SPN for specific pipeline
	IF @SpecificPipelineName IS NOT NULL
		BEGIN
			--secondary defensive check for pipeline optional param
			IF NOT EXISTS
				( 
				SELECT [PipelineName] FROM [procfwk].[Pipelines] WHERE [PipelineName] = @SpecificPipelineName
				)
				BEGIN
					SET @ErrorDetails = 'Invalid Pipeline name. Please ensure the Pipeline metadata exists before trying to add authentication for it.'
					RAISERROR(@ErrorDetails, 16, 1);
					RETURN 0;
				END
			
			--spn may already exist for other pipelines
			IF NOT EXISTS
				(
				SELECT [PrincipalId] FROM [dbo].[ServicePrincipals] WHERE [PrincipalId] = @PrincipalId
				)
				BEGIN
					--add service principal
					INSERT INTO [dbo].[ServicePrincipals]
						( 
						[PrincipalName],
						[PrincipalId],
						[PrincipalSecret]
						)
					SELECT
						ISNULL(@PrincipalName, 'Unknown'),
						@PrincipalId,
						ENCRYPTBYPASSPHRASE(CONCAT(@TenantId, @DataFactory, @SpecificPipelineName), @PrincipalSecret)

					SET @CredentialId = SCOPE_IDENTITY()
				END
			ELSE
				BEGIN
					SELECT @CredentialId = [CredentialId] FROM [dbo].[ServicePrincipals] WHERE [PrincipalId] = @PrincipalId
				END

			--add single pipeline to SPN link
			INSERT INTO [procfwk].[PipelineAuthLink]
				(
				[PipelineId],
				[DataFactoryId],
				[CredentialId]
				)
			SELECT
				P.[PipelineId],
				D.[DataFactoryId],
				@CredentialId
			FROM
				[procfwk].[Pipelines] P
				INNER JOIN [procfwk].[DataFactorys] D
					ON P.[DataFactoryId] = D.[DataFactoryId]
			WHERE
				P.[PipelineName] = @SpecificPipelineName
				AND D.[DataFactoryName] = @DataFactory;
		END
	ELSE
		--add SPN for all pipelines in data factory
		BEGIN
			--add service principal
			INSERT INTO [dbo].[ServicePrincipals]
				( 
				[PrincipalName],
				[PrincipalId],
				[PrincipalSecret]
				)
			SELECT
				ISNULL(@PrincipalName, 'Unknown'),
				@PrincipalId,
				ENCRYPTBYPASSPHRASE(CONCAT(@TenantId, @DataFactory), @PrincipalSecret)

			SET @CredentialId = SCOPE_IDENTITY()

			--add link
			INSERT INTO [procfwk].[PipelineAuthLink]
				(
				[PipelineId],
				[DataFactoryId],
				[CredentialId]
				)
			SELECT
				P.[PipelineId],
				D.[DataFactoryId],
				@CredentialId
			FROM
				[procfwk].[Pipelines] P
				INNER JOIN [procfwk].[DataFactorys] D
					ON P.[DataFactoryId] = D.[DataFactoryId]
				LEFT OUTER JOIN [procfwk].[PipelineAuthLink] L
					ON P.[PipelineId] = L.[PipelineId]
			WHERE
				D.[DataFactoryName] = @DataFactory
				AND L.[PipelineId] IS NULL;
		END
END;
GO
PRINT N'Creating [procfwkHelpers].[AddRecipientPipelineAlerts]...';


GO
CREATE PROCEDURE [procfwkHelpers].[AddRecipientPipelineAlerts]
	(
	@RecipientName VARCHAR(255),
	@PipelineName NVARCHAR(200) = NULL,
	@AlertForStatus NVARCHAR(500) = 'All'
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ActualBitValue INT
	DECLARE @SQL NVARCHAR(MAX) = ''
	DECLARE @BitValue TABLE ([TotalBitValue] INT NOT NULL);

	--get alert status bit value
	SET @AlertForStatus = LTRIM(RTRIM(@AlertForStatus))
	SET @AlertForStatus = REPLACE(@AlertForStatus,' ','')
	SET @AlertForStatus = '''' + REPLACE(@AlertForStatus,',',''',''') + ''''

	SET @SQL = 
		'
		SELECT
			SUM([BitValue]) AS ''TotalBitValue''
		FROM
			[procfwk].[AlertOutcomes]
		WHERE
			[PipelineOutcomeStatus] IN (' + @AlertForStatus + ')
		'

	INSERT INTO @BitValue ([TotalBitValue]) EXECUTE(@SQL)
	SELECT @ActualBitValue = [TotalBitValue] FROM @BitValue
	
	--set link table
	IF @PipelineName IS NOT NULL
		BEGIN
			--add alert for specific pipeline if doesn't exist
			INSERT INTO [procfwk].[PipelineAlertLink]
				(
				[PipelineId],
				[RecipientId],
				[OutcomesBitValue]
				)			
			SELECT
				p.[PipelineId],
				r.[RecipientId],
				@ActualBitValue
			FROM
				[procfwk].[Pipelines] p
				INNER JOIN [procfwk].[Recipients] r
					ON r.[Name] = @RecipientName
				LEFT OUTER JOIN [procfwk].[PipelineAlertLink] al
					ON p.[PipelineId] = al.[PipelineId]
						AND r.[RecipientId] = al.[RecipientId]
			WHERE
				p.[PipelineName] = @PipelineName
				AND al.[PipelineId] IS NULL
				AND al.[RecipientId] IS NULL;
		END
	ELSE IF @PipelineName IS NULL
		BEGIN
			--remove and re-add alerts for all pipelines
			DELETE 
				al
			FROM 
				[procfwk].[PipelineAlertLink] al
				INNER JOIN [procfwk].[Recipients] r
					ON al.[RecipientId] = r.[RecipientId]
			WHERE
				r.[Name] = @RecipientName;
						
			INSERT INTO [procfwk].[PipelineAlertLink]
				(
				[PipelineId],
				[RecipientId],
				[OutcomesBitValue]
				)
			SELECT
				p.[PipelineId],
				r.[RecipientId],
				@ActualBitValue
			FROM
				[procfwk].[Recipients] r
				CROSS JOIN [procfwk].[Pipelines] p
			WHERE
				r.[Name] = @RecipientName;
		END;
END
GO
PRINT N'Creating [procfwkHelpers].[AddProperty]...';


GO
CREATE PROCEDURE [procfwkHelpers].[AddProperty]
	(
	@PropertyName VARCHAR(128),
	@PropertyValue NVARCHAR(MAX),
	@Description NVARCHAR(MAX) = NULL
	)
AS
BEGIN
	
	SET NOCOUNT ON;

	--defensive check
	IF EXISTS
		(
		SELECT * FROM [procfwk].[Properties] WHERE [PropertyName] = @PropertyName AND [ValidTo] IS NOT NULL
		)
		AND NOT EXISTS
		(
		SELECT * FROM [procfwk].[Properties] WHERE [PropertyName] = @PropertyName AND [ValidTo] IS NULL
		)
		BEGIN
			WITH lastValue AS
				(
				SELECT
					[PropertyId],
					ROW_NUMBER() OVER (PARTITION BY [PropertyName] ORDER BY [ValidTo] ASC) AS Rn
				FROM
					[procfwk].[Properties]
				WHERE
					[PropertyName] = @PropertyName
				)
			--reset property if valid to date has been incorrectly set
			UPDATE
				prop
			SET
				[ValidTo] = NULL
			FROM
				[procfwk].[Properties] prop
				INNER JOIN lastValue
					ON prop.[PropertyId] = lastValue.[PropertyId]
			WHERE
				lastValue.[Rn] = 1
		END
	

	--upsert property
	;WITH sourceTable AS
		(
		SELECT
			@PropertyName AS PropertyName,
			@PropertyValue AS PropertyValue,
			@Description AS [Description],
			GETUTCDATE() AS StartEndDate
		)
	--insert new version of existing property from MERGE OUTPUT
	INSERT INTO [procfwk].[Properties]
		(
		[PropertyName],
		[PropertyValue],
		[Description],
		[ValidFrom]
		)
	SELECT
		[PropertyName],
		[PropertyValue],
		[Description],
		GETUTCDATE()
	FROM
		(
		MERGE INTO
			[procfwk].[Properties] targetTable
		USING
			sourceTable
				ON sourceTable.[PropertyName] = targetTable.[PropertyName]	
		--set valid to date on existing property
		WHEN MATCHED AND [ValidTo] IS NULL THEN 
			UPDATE
			SET
				targetTable.[ValidTo] = sourceTable.[StartEndDate]
		--add new property
		WHEN NOT MATCHED BY TARGET THEN
			INSERT
				(
				[PropertyName],
				[PropertyValue],
				[Description],
				[ValidFrom]
				)
			VALUES
				(
				sourceTable.[PropertyName],
				sourceTable.[PropertyValue],
				sourceTable.[Description],
				sourceTable.[StartEndDate]
				)
			--for new entry of existing record
			OUTPUT
				$action AS [Action],
				sourceTable.*
			) AS MergeOutput
		WHERE
			MergeOutput.[Action] = 'UPDATE';
END;
GO
PRINT N'Creating [procfwkHelpers].[AddPipelineDependant]...';


GO
CREATE PROCEDURE [procfwkHelpers].[AddPipelineDependant]
	(
	@PipelineName NVARCHAR(200),
	@DependantPipelineName NVARCHAR(200)
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @PipelineId INT;
	DECLARE @DependantPipelineId INT;

	--get pipeline ids
	SELECT
		@PipelineId = [PipelineId]
	FROM
		[procfwk].[Pipelines]
	WHERE
		[PipelineName] = @PipelineName;

	SELECT
		@DependantPipelineId = [PipelineId]
	FROM
		[procfwk].[Pipelines]
	WHERE
		[PipelineName] = @DependantPipelineName;

	--defensive checks
	IF @PipelineId IS NULL
	BEGIN
		RAISERROR('Pipeline not found in pipelines table.', 16,1);
		RETURN 0;
	END;

	IF @DependantPipelineId IS NULL
	BEGIN
		RAISERROR('Dependant pipeline not found in pipelines table.', 16,1);
		RETURN 0;
	END;

	IF @PipelineId = @DependantPipelineId
	BEGIN
		RAISERROR('Pipeline cannot be dependant on itself.', 16,1);
		RETURN 0;
	END;

	IF EXISTS
		(
		SELECT 
			*
		FROM 
			[procfwk].[Pipelines] pp
			INNER JOIN [procfwk].[Pipelines] dp
				ON dp.[PipelineId] = @DependantPipelineId
		WHERE
			pp.[PipelineId] = @PipelineId
			AND pp.[StageId] = dp.[StageId]
		)
		BEGIN
			RAISERROR('Pipeline and dependent pipeline cannot be in the same execution stage.', 16,1);
			RETURN 0;
		END;

	--final soft check and insert
	IF EXISTS
		(
		SELECT 
			* 
		FROM 
			[procfwk].[PipelineDependencies] 
		WHERE
			[PipelineId] = @PipelineId
			AND [DependantPipelineId] = @DependantPipelineId
		)
		BEGIN
			PRINT 'Dependency already exists. Nothing added.'
			RETURN 0;
		END
	ELSE
		BEGIN
			INSERT INTO [procfwk].[PipelineDependencies]
				(
				[PipelineId],
				[DependantPipelineId]
				)
			VALUES
				(
				@PipelineId,
				@DependantPipelineId
				)
		END;
END;
GO
PRINT N'Creating [procfwkHelpers].[AddPipelineViaPowerShell]...';


GO
CREATE PROCEDURE [procfwkHelpers].[AddPipelineViaPowerShell]
	(
	@ResourceGroup NVARCHAR(200),
	@DataFactoryName NVARCHAR(200),
	@PipelineName NVARCHAR(200)
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @DataFactoryId INT
	DECLARE @StageId INT
	DECLARE @StageName VARCHAR(255) = 'PoShAdded'

	--get/set data factory
	IF EXISTS
		(
		SELECT * FROM [procfwk].[DataFactorys] WHERE [DataFactoryName] = @DataFactoryName AND [ResourceGroupName] = @ResourceGroup
		)
		BEGIN
			SELECT @DataFactoryId = [DataFactoryId] FROM [procfwk].[DataFactorys] WHERE [DataFactoryName] = @DataFactoryName AND [ResourceGroupName] = @ResourceGroup;
		END
	ELSE
		BEGIN
			INSERT INTO [procfwk].[DataFactorys]
				(
				[DataFactoryName],
				[ResourceGroupName],
				[Description]
				)
			VALUES
				(
				@DataFactoryName,
				@ResourceGroup,
				'Added via PowerShell.'
				)

			SELECT
				@DataFactoryId = SCOPE_IDENTITY();
		END

	--get/set stage
	IF EXISTS
		(
		SELECT * FROM [procfwk].[Stages] WHERE [StageName] = @StageName
		)
		BEGIN
			SELECT @StageId = [StageId] FROM [procfwk].[Stages] WHERE [StageName] = @StageName;
		END;
	ELSE
		BEGIN
			INSERT INTO [procfwk].[Stages]
				(
				[StageName],
				[StageDescription],
				[Enabled]
				)
			VALUES
				(
				@StageName,
				'Added via PowerShell.',
				1
				);

			SELECT
				@StageId = SCOPE_IDENTITY();
		END;

	--upsert pipeline
	;WITH sourceData AS
		(
		SELECT
			@DataFactoryId AS DataFactoryId,
			@PipelineName AS PipelineName,
			@StageId AS StageId,
			NULL AS LogicalPredecessorId,
			1 AS [Enabled]
		)
	MERGE INTO [procfwk].[Pipelines] AS tgt
	USING 
		sourceData AS src
			ON tgt.[DataFactoryId] = src.[DataFactoryId]
				AND tgt.[PipelineName] = src.[PipelineName]
	WHEN MATCHED THEN
		UPDATE
		SET
			tgt.[StageId] = src.[StageId],
			tgt.[LogicalPredecessorId] = src.[LogicalPredecessorId],
			tgt.[Enabled] = src.[Enabled]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT
			(
			[DataFactoryId],
			[StageId],
			[PipelineName], 
			[LogicalPredecessorId],
			[Enabled]
			)
		VALUES
			(
			src.[DataFactoryId],
			src.[StageId],
			src.[PipelineName], 
			src.[LogicalPredecessorId],
			src.[Enabled]
			);
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultRecipientPipelineAlerts]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultRecipientPipelineAlerts]
AS
BEGIN
	EXEC [procfwkHelpers].[AddRecipientPipelineAlerts]
		@RecipientName = N'Test User 1',
		@AlertForStatus = 'All';

	EXEC [procfwkHelpers].[AddRecipientPipelineAlerts]
		@RecipientName = N'Test User 2',
		@PipelineName = 'Intentional Error',
		@AlertForStatus = 'Failed';

	EXEC [procfwkHelpers].[AddRecipientPipelineAlerts]
		@RecipientName = N'Test User 3',
		@PipelineName = 'Wait 1',
		@AlertForStatus = 'Success, Failed, Cancelled';	
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultRecipients]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultRecipients]
AS
BEGIN
	DECLARE @Recipients TABLE
		(
		[Name] [VARCHAR](255) NULL,
		[EmailAddress] [NVARCHAR](500) NOT NULL,
		[MessagePreference] [CHAR](3) NOT NULL,
		[Enabled] [BIT] NOT NULL
		)

	INSERT INTO @Recipients
		(
		[Name],
		[EmailAddress],
		[MessagePreference],
		[Enabled]
		)
	VALUES
		('Test User 1','test.user1@adfprocfwk.com', 'TO', 1),
		('Test User 2','test.user2@adfprocfwk.com', 'CC', 1),
		('Test User 3','test.user3@adfprocfwk.com', 'BCC', 1);

	MERGE INTO [procfwk].[Recipients] AS tgt
	USING 
		@Recipients AS src
			ON tgt.[Name] = src.[Name]
	WHEN MATCHED THEN
		UPDATE
		SET
			tgt.[EmailAddress] = src.[EmailAddress],
			tgt.[MessagePreference] = src.[MessagePreference],
			tgt.[Enabled] = src.[Enabled]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT
			(
			[Name],
			[EmailAddress],
			[MessagePreference],
			[Enabled]
			)
		VALUES
			(
			src.[Name],
			src.[EmailAddress],
			src.[MessagePreference],
			src.[Enabled]
			)
	WHEN NOT MATCHED BY SOURCE THEN
		DELETE;	
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultAlertOutcomes]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultAlertOutcomes]
AS
BEGIN
	TRUNCATE TABLE [procfwk].[AlertOutcomes];

	INSERT INTO [procfwk].[AlertOutcomes] 
		(
		[PipelineOutcomeStatus]
		)
	VALUES 
		('All'),
		('Success'),
		('Failed'),
		('Unknown'),
		('Cancelled');
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultPipelineDependants]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultPipelineDependants]
AS
BEGIN
	EXEC [procfwkHelpers].[AddPipelineDependant]
		@PipelineName = 'Intentional Error',
		@DependantPipelineName = 'Wait 5';

	EXEC [procfwkHelpers].[AddPipelineDependant]
		@PipelineName = 'Intentional Error',
		@DependantPipelineName = 'Wait 6';

	EXEC [procfwkHelpers].[AddPipelineDependant]
		@PipelineName = 'Wait 6',
		@DependantPipelineName = 'Wait 9';

	EXEC [procfwkHelpers].[AddPipelineDependant]
		@PipelineName = 'Wait 9',
		@DependantPipelineName = 'Wait 10';
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultPipelineParameters]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultPipelineParameters]
AS
BEGIN
	DECLARE @PipelineParameters TABLE
		(
		[PipelineId] [INT] NOT NULL,
		[ParameterName] [VARCHAR](128) NOT NULL,
		[ParameterValue] [NVARCHAR](MAX) NULL
		)

	INSERT @PipelineParameters
		(
		[PipelineId], 
		[ParameterName], 
		[ParameterValue]
		) 
	VALUES 
		(1, 'WaitTime', '3'),
		(2, 'WaitTime', '6'),
		(6, 'WaitTime', '9'),
		(4, 'WaitTime', '5'),
		(5, 'WaitTime', '2'),
		(3, 'RaiseErrors', 'false'),
		(3, 'WaitTime', '10'),
		(7, 'WaitTime', '3'),
		(8, 'WaitTime', '5'),
		(9, 'WaitTime', '7'),
		(11, 'WaitTime', '10');

	MERGE INTO [procfwk].[PipelineParameters]  AS tgt
	USING 
		@PipelineParameters AS src
			ON tgt.[PipelineId] = src.[PipelineId]
				AND tgt.[ParameterName] = src.[ParameterName]
	WHEN MATCHED THEN
		UPDATE
		SET
			tgt.[ParameterValue] = src.[ParameterValue]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT
			(
			[PipelineId], 
			[ParameterName], 
			[ParameterValue]
			) 
		VALUES
			(
			src.[PipelineId], 
			src.[ParameterName], 
			src.[ParameterValue]
			) 
	WHEN NOT MATCHED BY SOURCE THEN
		DELETE;	
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultPipelines]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultPipelines]
AS
BEGIN
	DECLARE @Pipelines TABLE
		(
		[DataFactoryId] [INT] NOT NULL,
		[StageId] [INT] NOT NULL,
		[PipelineName] [NVARCHAR](200) NOT NULL,
		[LogicalPredecessorId] [INT] NULL,
		[Enabled] [BIT] NOT NULL
		)

	INSERT @Pipelines
		(
		[DataFactoryId],
		[StageId],
		[PipelineName], 
		[LogicalPredecessorId],
		[Enabled]
		) 
	VALUES 
		(1,1	,'Wait 1'				,NULL		,1),
		(1,1	,'Wait 2'				,NULL		,1),
		(1,1	,'Intentional Error'	,NULL		,1),
		(1,1	,'Wait 3'				,NULL		,1),
		(1,2	,'Wait 4'				,NULL		,1),
		(1,2	,'Wait 5'				,1			,1),
		(1,2	,'Wait 6'				,1			,1),
		(1,2	,'Wait 7'				,NULL		,1),
		(1,3	,'Wait 8'				,1			,1),
		(1,3	,'Wait 9'				,6			,1),
		(1,4	,'Wait 10'				,9			,1);

	MERGE INTO [procfwk].[Pipelines] AS tgt
	USING 
		@Pipelines AS src
			ON tgt.[PipelineName] = src.[PipelineName]
	WHEN MATCHED THEN
		UPDATE
		SET
			tgt.[DataFactoryId] = src.[DataFactoryId],
			tgt.[StageId] = src.[StageId],
			tgt.[LogicalPredecessorId] = src.[LogicalPredecessorId],
			tgt.[Enabled] = src.[Enabled]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT
			(
			[DataFactoryId],
			[StageId],
			[PipelineName], 
			[LogicalPredecessorId],
			[Enabled]
			)
		VALUES
			(
			src.[DataFactoryId],
			src.[StageId],
			src.[PipelineName], 
			src.[LogicalPredecessorId],
			src.[Enabled]
			)
	WHEN NOT MATCHED BY SOURCE THEN
		DELETE;	
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultDataFactorys]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultDataFactorys]
AS
BEGIN
	DECLARE @DataFactorys TABLE 
		(
		[DataFactoryName] [NVARCHAR](200) NOT NULL,
		[ResourceGroupName] [NVARCHAR](200) NOT NULL,
		[Description] [NVARCHAR](MAX) NULL
		)
	
	INSERT INTO @DataFactorys
		(
		[DataFactoryName],
		[Description],
		[ResourceGroupName]
		)
	VALUES
		('FrameworkFactory','Example Data Factory used for development.','ADF.procfwk'),
		('FrameworkFactoryDev','Example Data Factory used for development deployments.','ADF.procfwk'),
		('FrameworkFactoryTest','Example Data Factory used for testing.','ADF.procfwk'),
		('WorkersFactory','Example Data Factory used to house worker pipelines.','ADF.procfwk');

	MERGE INTO [procfwk].[DataFactorys] AS tgt
	USING 
		@DataFactorys AS src
			ON tgt.[DataFactoryName] = src.[DataFactoryName]
	WHEN MATCHED THEN
		UPDATE
		SET
			tgt.[Description] = src.[Description],
			tgt.[ResourceGroupName] = src.[ResourceGroupName]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT
			(
			[DataFactoryName],
			[Description],
			[ResourceGroupName]
			)
		VALUES
			(
			src.[DataFactoryName],
			src.[Description],
			src.[ResourceGroupName]
			)
	WHEN NOT MATCHED BY SOURCE THEN
		DELETE;
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultStages]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultStages]
AS
BEGIN
	DECLARE @Stages TABLE
		(
		[StageName] [VARCHAR](225) NOT NULL,
		[StageDescription] [VARCHAR](4000) NULL,
		[Enabled] [BIT] NOT NULL
		)
	
	INSERT @Stages
		(
		[StageName], 
		[StageDescription], 
		[Enabled]
		) 
	VALUES 
		('Extract', N'Ingest all data from source systems.', 1),
		('Transform', N'Transform ingested data and apply business logic.', 1),
		('Load', N'Load transformed data into semantic layer.', 1),
		('Serve', N'Load transformed data into semantic layer.', 1);	

	MERGE INTO [procfwk].[Stages] AS tgt
	USING 
		@Stages AS src
			ON tgt.[StageName] = src.[StageName]
	WHEN MATCHED THEN
		UPDATE
		SET
			tgt.[StageDescription] = src.[StageDescription],
			tgt.[Enabled] = src.[Enabled]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT
			(
			[StageName],
			[StageDescription],
			[Enabled]
			)
		VALUES
			(
			src.[StageName],
			src.[StageDescription],
			src.[Enabled]
			)
	WHEN NOT MATCHED BY SOURCE THEN
		DELETE;	
END;
GO
PRINT N'Creating [procfwkHelpers].[SetDefaultProperties]...';


GO
CREATE PROCEDURE [procfwkHelpers].[SetDefaultProperties]
AS
BEGIN
	EXEC [procfwkHelpers].[AddProperty] 
		@PropertyName = 'TenantId',
		@PropertyValue = '1234-1234-1234-1234-1234',
		@Description = 'Used to provide authentication throughout the framework execution.';

	EXEC [procfwkHelpers].[AddProperty] 
		@PropertyName = 'SubscriptionId',
		@PropertyValue = '1234-1234-1234-1234-1234',
		@Description = 'Used to provide authentication throughout the framework execution.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'OverideRestart',
		@PropertyValue = N'0',
		@Description = N'Should processing not be restarted from the point of failure or should a new execution will be created regardless. 1 = Start New, 0 = Restart. ';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'PipelineStatusCheckDuration',
		@PropertyValue = N'30',
		@Description = N'Duration applied to the Wait activity within the Infant pipeline Until iterations.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'UnknownWorkerResultBlocks',
		@PropertyValue = N'1',
		@Description = N'If a worker pipeline returns an unknown status. Should this block and fail downstream pipeline? 1 = Yes, 0 = No.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'CancelledWorkerResultBlocks',
		@PropertyValue = N'1',
		@Description = N'If a worker pipeline returns an cancelled status. Should this block and fail downstream pipeline? 1 = Yes, 0 = No.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'UseFrameworkEmailAlerting',
		@PropertyValue = N'1',
		@Description = N'Do you want the framework to handle pipeline email alerts via the database metadata? 1 = Yes, 0 = No.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'EmailAlertBodyTemplate',
		@PropertyValue = 
		N'<hr/><strong>Pipeline Name: </strong>##PipelineName###<br/>
	<strong>Status: </strong>##Status###<br/><br/>
	<strong>Execution ID: </strong>##ExecId###<br/>
	<strong>Run ID: </strong>##RunId###<br/><br/>
	<strong>Start Date Time: </strong>##StartDateTime###<br/>
	<strong>End Date Time: </strong>##EndDateTime###<br/>
	<strong>Duration (Minutes): </strong>##Duration###<br/><br/>
	<strong>Called by Data Factory: </strong>##CalledByADF###<br/>
	<strong>Executed by Data Factory: </strong>##ExecutedByADF###<br/><hr/>',
		@Description = N'Basic HTML template of execution information used as the eventual body in email alerts sent.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'FailureHandling',
		@PropertyValue = N'Simple',
		@Description = N'Accepted values: None, Simple, DependencyChain. Controls processing bahaviour in the event of Worker failures. See v1.8 release notes for full details.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'SPNHandlingMethod',
		@PropertyValue = N'StoreInDatabase',
		@Description = N'Accepted values: StoreInDatabase, StoreInKeyVault. See v1.8.2 release notes for full details.';

	EXEC [procfwkHelpers].[AddProperty]
		@PropertyName = N'ExecutionPrecursorProc',
		@PropertyValue = N'[dbo].[ExampleCustomExecutionPrecursor]',
		@Description = N'This procedure will be called first in the parent pipeline and can be used to perform/update any required custom behaviour in the framework execution. For example, enable/disable Worker pipelines given a certain run time/day. Invalid proc name values will be ignored.'
END;
GO
PRINT N'Creating [procfwkHelpers].[DeleteMetadataWithoutIntegrity]...';


GO
CREATE PROCEDURE [procfwkHelpers].[DeleteMetadataWithoutIntegrity]
AS
BEGIN

	DECLARE @SQL NVARCHAR(MAX) = ''

	;WITH procfwkTables AS
		(
		SELECT
			QUOTENAME(s.[name]) + '.' + QUOTENAME(o.[name]) AS FullName
		FROM
			sys.objects o
			INNER JOIN sys.schemas s
				ON o.[schema_id] = s.[schema_id]
		WHERE
			s.[name] LIKE 'procfwk%'
			AND o.[type] = 'U'

		UNION 

		SELECT
			QUOTENAME(s.[name]) + '.' + QUOTENAME(o.[name]) AS FullName
		FROM
			sys.objects o
			INNER JOIN sys.schemas s
				ON o.[schema_id] = s.[schema_id]
		WHERE
			o.[name] = 'ServicePrincipals'
			AND o.[type] = 'U'
		)

	SELECT --tables must exist or wouldnt appear in sys.objects query
		@SQL += 'DELETE FROM ' + [FullName] + ';' + CHAR(13)
	FROM 
		procfwkTables

	EXEC(@SQL);
END;
GO
PRINT N'Creating [procfwkHelpers].[DeleteMetadataWithIntegrity]...';


GO
CREATE PROCEDURE [procfwkHelpers].[DeleteMetadataWithIntegrity]
AS
BEGIN
	/*
	DELETE ORDER IMPORTANT FOR REFERENTIAL INTEGRITY
	*/

	--CurrentExecution
	IF OBJECT_ID(N'[procfwk].[CurrentExecution]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[CurrentExecution];
		END;

	--ExecutionLog
	IF OBJECT_ID(N'[procfwk].[ExecutionLog]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[ExecutionLog];
		END

	--ErrorLog
	IF OBJECT_ID(N'[procfwk].[ExecutionLog]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[ErrorLog];
		END

	--PipelineDependencies
	IF OBJECT_ID(N'[procfwk].[PipelineDependencies]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineDependencies];
			DBCC CHECKIDENT ('[procfwk].[PipelineDependencies]', RESEED, 0);
		END;

	--PipelineAlertLink
	IF OBJECT_ID(N'[procfwk].[PipelineAlertLink]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineAlertLink];
			DBCC CHECKIDENT ('[procfwk].[PipelineAlertLink]', RESEED, 0);
		END;

	--Recipients
	IF OBJECT_ID(N'[procfwk].[Recipients]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Recipients];
			DBCC CHECKIDENT ('[procfwk].[Recipients]', RESEED, 0);
		END;

	--AlertOutcomes
	IF OBJECT_ID(N'[procfwk].[AlertOutcomes]') IS NOT NULL 
		BEGIN
			TRUNCATE TABLE [procfwk].[AlertOutcomes];
		END;

	--PipelineAuthLink
	IF OBJECT_ID(N'[procfwk].[PipelineAuthLink]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineAuthLink];
			DBCC CHECKIDENT ('[procfwk].[PipelineAuthLink]', RESEED, 0);
		END;

	--ServicePrincipals
	IF OBJECT_ID(N'[dbo].[ServicePrincipals]') IS NOT NULL 
		BEGIN
			DELETE FROM [dbo].[ServicePrincipals];
			DBCC CHECKIDENT ('[dbo].[ServicePrincipals]', RESEED, 0);
		END;

	--Properties
	IF OBJECT_ID(N'[procfwk].[Properties]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Properties];
			DBCC CHECKIDENT ('[procfwk].[Properties]', RESEED, 0);
		END;

	--PipelineParameters
	IF OBJECT_ID(N'[procfwk].[PipelineParameters]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[PipelineParameters];
			DBCC CHECKIDENT ('[procfwk].[PipelineParameters]', RESEED, 0);
		END;

	--Pipelines
	IF OBJECT_ID(N'[procfwk].[Pipelines]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Pipelines];
			DBCC CHECKIDENT ('[procfwk].[Pipelines]', RESEED, 0);
		END;

	--DataFactorys
	IF OBJECT_ID(N'[procfwk].[DataFactorys]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[DataFactorys];
			DBCC CHECKIDENT ('[procfwk].[DataFactorys]', RESEED, 0);
		END;

	--Stages
	IF OBJECT_ID(N'[procfwk].[Stages]') IS NOT NULL 
		BEGIN
			DELETE FROM [procfwk].[Stages];
			DBCC CHECKIDENT ('[procfwk].[Stages]', RESEED, 0);
		END;
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineFailed]...';


GO
CREATE PROCEDURE [procfwk].[SetLogPipelineFailed]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT,
	@RunId UNIQUEIDENTIFIER = NULL
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ErrorDetail VARCHAR(500)

	--mark specific failure pipeline
	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[PipelineStatus] = 'Failed'
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId

	--persist failed pipeline records to long term log
	INSERT INTO [procfwk].[ExecutionLog]
		(
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
		)
	SELECT
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
	FROM
		[procfwk].[CurrentExecution]
	WHERE
		[PipelineStatus] = 'Failed'
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId;
	
	IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'None'
		BEGIN
			--do nothing allow processing to carry on regardless
			RETURN 0;
		END;
		
	ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'Simple'
		BEGIN
			--flag all downstream stages as blocked
			UPDATE
				[procfwk].[CurrentExecution]
			SET
				[PipelineStatus] = 'Blocked',
				[IsBlocked] = 1
			WHERE
				[LocalExecutionId] = @ExecutionId
				AND [StageId] > @StageId
			
			--raise error to stop processing
			IF @RunId IS NOT NULL
				BEGIN
					SET @ErrorDetail = 'Pipeline execution failed. Check Run ID: ' + CAST(@RunId AS CHAR(36)) + ' in ADF monitoring for details.'
				END;
			ELSE
				BEGIN
					SET @ErrorDetail = 'Pipeline execution failed. See ADF monitoring for details.'
				END;

			RAISERROR(@ErrorDetail,16,1);
		
			RETURN 0;
		END;
	
	ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'DependencyChain'
		BEGIN
			EXEC [procfwk].[SetExecutionBlockDependants]
				@ExecutionId = @ExecutionId,
				@PipelineId = @PipelineId
		END;
	ELSE
		BEGIN
			RAISERROR('Unknown failure handling state.',16,1);
			RETURN 0;
		END;
END;
GO
PRINT N'Creating [procfwk].[SetLogActivityFailed]...';


GO
CREATE PROCEDURE [procfwk].[SetLogActivityFailed]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT,
	@CallingActivity VARCHAR(255)
	)
AS

BEGIN
	SET NOCOUNT ON;
	
	--mark specific failure pipeline
	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[PipelineStatus] = @CallingActivity + 'Error'
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId

	--persist failed pipeline records to long term log
	INSERT INTO [procfwk].[ExecutionLog]
		(
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
		)
	SELECT
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
	FROM
		[procfwk].[CurrentExecution]
	WHERE
		[PipelineStatus] = @CallingActivity + 'Error'
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId
	
	--decide how to proceed with error/failure depending on framework property configuration
	IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'None'
		BEGIN
			--do nothing allow processing to carry on regardless
			RETURN 0;
		END;
		
	ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'Simple'
		BEGIN
			--flag all downstream stages as blocked
			UPDATE
				[procfwk].[CurrentExecution]
			SET
				[PipelineStatus] = 'Blocked',
				[IsBlocked] = 1
			WHERE
				[LocalExecutionId] = @ExecutionId
				AND [StageId] > @StageId;
		END;
	
	ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'DependencyChain'
		BEGIN
			EXEC [procfwk].[SetExecutionBlockDependants]
				@ExecutionId = @ExecutionId,
				@PipelineId = @PipelineId
		END;
	ELSE
		BEGIN
			RAISERROR('Unknown failure handling state.',16,1);
			RETURN 0;
		END;
END;
GO
PRINT N'Creating [procfwk].[SetLogPipelineUnknown]...';


GO
CREATE PROCEDURE [procfwk].[SetLogPipelineUnknown]
	(
	@ExecutionId UNIQUEIDENTIFIER,
	@StageId INT,
	@PipelineId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ErrorDetail VARCHAR(500);

	--mark specific failure pipeline
	UPDATE
		[procfwk].[CurrentExecution]
	SET
		[PipelineStatus] = 'Unknown'
	WHERE
		[LocalExecutionId] = @ExecutionId
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId

	--persist unknown pipeline records to long term log
	INSERT INTO [procfwk].[ExecutionLog]
		(
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
		)
	SELECT
		[LocalExecutionId],
		[StageId],
		[PipelineId],
		[CallingDataFactoryName],
		[ResourceGroupName],
		[DataFactoryName],
		[PipelineName],
		[StartDateTime],
		[PipelineStatus],
		[EndDateTime],
		[AdfPipelineRunId],
		[PipelineParamsUsed]
	FROM
		[procfwk].[CurrentExecution]
	WHERE
		[PipelineStatus] = 'Unknown'
		AND [StageId] = @StageId
		AND [PipelineId] = @PipelineId;

	--block down stream stages?
	IF ([procfwk].[GetPropertyValueInternal]('UnknownWorkerResultBlocks')) = 1
	BEGIN	
		--decide how to proceed with error/failure depending on framework property configuration
		IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'None'
			BEGIN
				--do nothing allow processing to carry on regardless
				RETURN 0;
			END;
		
		ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'Simple'
			BEGIN
				--flag all downstream stages as blocked
				UPDATE
					[procfwk].[CurrentExecution]
				SET
					[PipelineStatus] = 'Blocked',
					[IsBlocked] = 1
				WHERE
					[LocalExecutionId] = @ExecutionId
					AND [StageId] > @StageId

				SET @ErrorDetail = 'Pipeline execution has an unknown status. Blocking downstream stages as a precaution.'

				RAISERROR(@ErrorDetail,16,1);
				RETURN 0;
			END;
		ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'DependencyChain'
			BEGIN
				EXEC [procfwk].[SetExecutionBlockDependants]
					@ExecutionId = @ExecutionId,
					@PipelineId = @PipelineId
			END;
		ELSE
			BEGIN
				RAISERROR('Unknown failure handling state.',16,1);
				RETURN 0;
			END;
	END;
END;
GO
PRINT N'Creating [procfwk].[CheckForBlockedPipelines]...';


GO
CREATE PROCEDURE [procfwk].[CheckForBlockedPipelines]
	(
	@StageId INT
	)
AS
BEGIN
	SET NOCOUNT ON;

	IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'None'
		BEGIN
			--do nothing allow processing to carry on regardless
			RETURN 0;
		END;
		
	ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'Simple'
		BEGIN
			IF EXISTS
				(
				SELECT 
					*
				FROM 
					[procfwk].[CurrentExecution]
				WHERE 
					[StageId] = @StageId
					AND [IsBlocked] = 1
				)
				BEGIN		
					--Saves the child pipeline and activities being called throwing the exception at this level.
					RAISERROR('All pipelines are blocked. Stopping processing.',16,1); 
					--If not thrown here, the proc [procfwk].[UpdateExecutionLog] would eventually throw an exception.
					RETURN 0;
				END			
		END;
	
	ELSE IF ([procfwk].[GetPropertyValueInternal]('FailureHandling')) = 'DependencyChain'
		BEGIN
			IF EXISTS
				(
				SELECT 
					*
				FROM 
					[procfwk].[CurrentExecution]
				WHERE 
					[StageId] = @StageId
					AND [IsBlocked] = 1
				)
				BEGIN		
					DECLARE @PipelineId INT;
					DECLARE @Cursor CURSOR ;

					SET @Cursor = CURSOR FOR 
											SELECT 
												[PipelineId] 
											FROM 
												[procfwk].[CurrentExecution] 
											WHERE 
												[StageId] = @StageId 
												AND [IsBlocked] = 1

					OPEN @Cursor
					FETCH NEXT FROM @Cursor INTO @PipelineId
					
					WHILE @@FETCH_STATUS = 0
					BEGIN 
						EXEC [procfwk].[SetExecutionBlockDependants]
							@PipelineId = @PipelineId;
						
						FETCH NEXT FROM @Cursor INTO @PipelineId;
					END;
					CLOSE @Cursor;
					DEALLOCATE @Cursor;
				END;
		END;
	ELSE
		BEGIN
			RAISERROR('Unknown failure handling state.',16,1);
			RETURN 0;
		END;
END;
GO
PRINT N'Creating [procfwk].[ExecutionWrapper]...';


GO
CREATE PROCEDURE [procfwk].[ExecutionWrapper]
	(
	@CallingDataFactory NVARCHAR(200)
	)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @RestartStatus BIT

	IF @CallingDataFactory IS NULL
		SET @CallingDataFactory = 'Unknown';

	--get restart overide property	
	SELECT @RestartStatus = [procfwk].[GetPropertyValueInternal]('OverideRestart')

	--check for running execution
	IF EXISTS
		(
		SELECT * FROM [procfwk].[CurrentExecution] WHERE ISNULL([PipelineStatus],'') = 'Running'
		)
		BEGIN
			RAISERROR('There is already an execution run in progress. Stop this via Data Factory before restarting.',16,1);
			RETURN 0;
		END;	

	--reset and restart execution
	IF EXISTS
		(
		SELECT * FROM [procfwk].[CurrentExecution] WHERE ISNULL([PipelineStatus],'') <> 'Success'
		) 
		AND @RestartStatus = 0
		BEGIN
			EXEC [procfwk].[ResetExecution]
		END
	--capture failed execution and run new anyway
	ELSE IF EXISTS
		(
		SELECT * FROM [procfwk].[CurrentExecution]
		)
		AND @RestartStatus = 1
		BEGIN
			EXEC [procfwk].[UpdateExecutionLog]
				@PerformErrorCheck = 0; --Special case when OverideRestart = 1;

			EXEC [procfwk].[CreateNewExecution] 
				@CallingDataFactoryName = @CallingDataFactory
		END
	--no restart considerations, just create new execution
	ELSE
		BEGIN
			EXEC [procfwk].[CreateNewExecution] 
				@CallingDataFactoryName = @CallingDataFactory
		END
END;
GO
PRINT N'Creating [procfwkTesting].[ResetMetadata]...';


GO
CREATE PROCEDURE [procfwkTesting].[ResetMetadata]
AS
BEGIN	
	EXEC [procfwkHelpers].[SetDefaultProperties];
	EXEC [procfwkHelpers].[SetDefaultDataFactorys];
	EXEC [procfwkHelpers].[SetDefaultStages];
	EXEC [procfwkHelpers].[SetDefaultPipelines];
	EXEC [procfwkHelpers].[SetDefaultPipelineParameters];
	EXEC [procfwkHelpers].[SetDefaultPipelineDependants];
	EXEC [procfwkHelpers].[SetDefaultRecipients];
	EXEC [procfwkHelpers].[SetDefaultAlertOutcomes];
	EXEC [procfwkHelpers].[SetDefaultRecipientPipelineAlerts];
END;
GO
PRINT N'Creating [procfwkTesting].[CleanUpMetadata]...';


GO
CREATE PROCEDURE [procfwkTesting].[CleanUpMetadata]
AS
BEGIN
	EXEC [procfwkHelpers].[DeleteMetadataWithIntegrity];
	EXEC [procfwkHelpers].[DeleteMetadataWithoutIntegrity];
END;
GO
PRINT N'Creating [procfwkHelpers].[AddServicePrincipalWrapper]...';


GO
CREATE PROCEDURE [procfwkHelpers].[AddServicePrincipalWrapper]
	(
	@DataFactory NVARCHAR(200),
	@PrincipalIdValue NVARCHAR(MAX),
	@PrincipalSecretValue NVARCHAR(MAX),
	@SpecificPipelineName NVARCHAR(200) = NULL,
	@PrincipalName NVARCHAR(256) = NULL
	)
AS
BEGIN
	
	IF ([procfwk].[GetPropertyValueInternal]('SPNHandlingMethod')) = 'StoreInDatabase'
		BEGIN
			EXEC [procfwk].[AddServicePrincipal]
				@DataFactory = @DataFactory,
				@PrincipalId = @PrincipalIdValue,
				@PrincipalSecret = @PrincipalSecretValue,
				@PrincipalName = @PrincipalName,
				@SpecificPipelineName = @SpecificPipelineName			
		END
	ELSE IF ([procfwk].[GetPropertyValueInternal]('SPNHandlingMethod')) = 'StoreInKeyVault'
		BEGIN
			EXEC [procfwk].[AddServicePrincipalUrls]
				@DataFactory = @DataFactory,
				@PrincipalIdUrl = @PrincipalIdValue,
				@PrincipalSecretUrl = @PrincipalSecretValue,
				@PrincipalName = @PrincipalName,
				@SpecificPipelineName = @SpecificPipelineName		
		END
	ELSE
		BEGIN
			RAISERROR('Unknown SPN insert method.',16,1);
			RETURN 0;
		END
END;
GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON SCHEMA::[procfwk] TO [adf_procfwkuser];


GO
PRINT N'Creating Permission...';


GO
GRANT SELECT
    ON SCHEMA::[procfwk] TO [adf_procfwkuser];


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
--load default metadata
EXEC [procfwkHelpers].[SetDefaultProperties];
EXEC [procfwkHelpers].[SetDefaultDataFactorys];
EXEC [procfwkHelpers].[SetDefaultStages];
EXEC [procfwkHelpers].[SetDefaultPipelines];
EXEC [procfwkHelpers].[SetDefaultPipelineParameters];
EXEC [procfwkHelpers].[SetDefaultPipelineDependants];
EXEC [procfwkHelpers].[SetDefaultRecipients];
EXEC [procfwkHelpers].[SetDefaultAlertOutcomes];
EXEC [procfwkHelpers].[SetDefaultRecipientPipelineAlerts]

--restore log data
DECLARE @Columns VARCHAR(MAX) = '';
DECLARE @Values VARCHAR(MAX) = '';
DECLARE @SQL VARCHAR(MAX) = '';

IF EXISTS
	(
	SELECT
		*
	FROM
		sys.objects o
		INNER JOIN sys.schemas s
			ON o.[schema_id] = s.[schema_id]
	WHERE
		o.[name] = 'ExecutionLog'
		AND s.[name] = 'procfwk'
	)
	AND EXISTS
	(
	SELECT
		*
	FROM
		sys.objects o
		INNER JOIN sys.schemas s
			ON o.[schema_id] = s.[schema_id]
	WHERE
		o.[name] = 'ExecutionLogBackup'
		AND s.[name] = 'dbo'
	)
	BEGIN
		;WITH oldTableColumns AS
			(
			SELECT
				c.[name] AS ColName
			FROM
				sys.objects o
				INNER JOIN sys.schemas s
					ON o.[schema_id] = s.[schema_id]
				INNER JOIN sys.columns c
					ON o.[object_id] = c.[object_id]
			WHERE
				s.[name] = 'dbo'
				AND o.[name] = 'ExecutionLogBackup'
				AND c.[name] <> 'LogId'
			),
			newTableColumns AS
			(
			SELECT
				c.[column_id] AS ColId,
				c.[name] AS ColName
			FROM
				sys.objects o
				INNER JOIN sys.schemas s
					ON o.[schema_id] = s.[schema_id]
				INNER JOIN sys.columns c
					ON o.[object_id] = c.[object_id]
			WHERE
				s.[name] = 'procfwk'
				AND o.[name] = 'ExecutionLog'
				AND c.[name] <> 'LogId'
			)
		SELECT  
			@Columns += QUOTENAME(newTableColumns.[ColName]) + ',' + CHAR(13),
			@Values += ISNULL(QUOTENAME(oldTableColumns.[ColName]),'NULL AS ''' + newTableColumns.[ColName] + '''' ) + ',' + CHAR(13)
		FROM
			newTableColumns 
			LEFT OUTER JOIN oldTableColumns
				ON newTableColumns.[ColName] = oldTableColumns.[ColName];

		SET @Columns = LEFT(@Columns,LEN(@Columns)-2);
		SET @Values = LEFT(@Values,LEN(@Values)-2);

		SET @SQL = 
		'
		INSERT INTO [procfwk].[ExecutionLog]
		(
		' + @Columns + '
		)
		SELECT
		' + @Values + '
		FROM
			[dbo].[ExecutionLogBackup]
		';

		PRINT @SQL;
		EXEC(@SQL);

		DECLARE @Before INT = (SELECT COUNT(0) FROM [dbo].[ExecutionLogBackup]);
		DECLARE @After INT = (SELECT COUNT(0) FROM [procfwk].[ExecutionLog]);

		IF (@Before = @After)
		BEGIN
			DROP TABLE [dbo].[ExecutionLogBackup]
		END;
	END;
DECLARE @ErrColumns VARCHAR(MAX) = '';
DECLARE @ErrValues VARCHAR(MAX) = '';
DECLARE @ErrSQL VARCHAR(MAX) = '';

IF EXISTS
	(
	SELECT
		*
	FROM
		sys.objects o
		INNER JOIN sys.schemas s
			ON o.[schema_id] = s.[schema_id]
	WHERE
		o.[name] = 'ErrorLog'
		AND s.[name] = 'procfwk'
	)
	AND EXISTS
	(
	SELECT
		*
	FROM
		sys.objects o
		INNER JOIN sys.schemas s
			ON o.[schema_id] = s.[schema_id]
	WHERE
		o.[name] = 'ErrorLogBackup'
		AND s.[name] = 'dbo'
	)
	BEGIN
		;WITH oldTableColumns AS
			(
			SELECT
				c.[name] AS 'ColName'
			FROM
				sys.objects o
				INNER JOIN sys.schemas s
					ON o.[schema_id] = s.[schema_id]
				INNER JOIN sys.columns c
					ON o.[object_id] = c.[object_id]
			WHERE
				s.[name] = 'dbo'
				AND o.[name] = 'ErrorLogBackup'
				AND c.[name] != 'LogId'
			),
			newTableColumns AS
			(
			SELECT
				c.[column_id] AS 'ColId',
				c.[name] AS 'ColName'
			FROM
				sys.objects o
				INNER JOIN sys.schemas s
					ON o.[schema_id] = s.[schema_id]
				INNER JOIN sys.columns c
					ON o.[object_id] = c.[object_id]
			WHERE
				s.[name] = 'procfwk'
				AND o.[name] = 'ErrorLog'
				AND c.[name] != 'LogId'
			)
		SELECT  
			@ErrColumns += QUOTENAME(newTableColumns.[ColName]) + ',' + CHAR(13),
			@ErrValues += ISNULL(QUOTENAME(oldTableColumns.[ColName]),'NULL AS ''' + newTableColumns.[ColName] + '''' ) + ',' + CHAR(13)
		FROM
			newTableColumns 
			LEFT OUTER JOIN oldTableColumns
				ON newTableColumns.[ColName] = oldTableColumns.[ColName];

		SET @ErrColumns = LEFT(@ErrColumns,LEN(@ErrColumns)-2);
		SET @ErrValues = LEFT(@ErrValues,LEN(@ErrValues)-2);

		SET @ErrSQL = 
		'
		INSERT INTO [procfwk].[ErrorLog]
		(
		' + @ErrColumns + '
		)
		SELECT
		' + @ErrValues + '
		FROM
			[dbo].[ErrorLogBackup]
		';

		PRINT @ErrSQL;
		EXEC(@ErrSQL);

		DECLARE @ErrBefore INT = (SELECT COUNT(0) FROM [dbo].[ErrorLogBackup]);
		DECLARE @ErrAfter INT = (SELECT COUNT(0) FROM [procfwk].[ErrorLog]);

		IF (@ErrBefore = @ErrAfter)
		BEGIN
			DROP TABLE [dbo].[ErrorLogBackup]
		END;
	END

--object transfers
IF OBJECT_ID(N'tempdb..#TransferHelperObjects') IS NOT NULL DROP PROCEDURE #TransferHelperObjects;
GO

CREATE PROCEDURE #TransferHelperObjects
	(
	@ObjectName NVARCHAR(128),
	@ObjectType CHAR(2)
	)
AS
BEGIN
	IF EXISTS
		(
		SELECT
			*
		FROM
			sys.objects o
			INNER JOIN sys.schemas s
				ON o.[schema_id] = s.[schema_id]
		WHERE
			o.[Name] = @ObjectName
			AND s.[name] = 'procfwk'
			AND o.[type] = @ObjectType
		)
		BEGIN
			PRINT 'Transferring: ' + @ObjectName;
			EXEC('ALTER SCHEMA [procfwkHelpers] TRANSFER [procfwk].[' + @ObjectName + '];')
		END;
END;
GO

EXEC #TransferHelperObjects 'AddProperty', 'P';
EXEC #TransferHelperObjects 'GetExecutionDetails', 'P';
EXEC #TransferHelperObjects 'AddRecipientPipelineAlerts', 'P';
EXEC #TransferHelperObjects 'DeleteRecipientAlerts', 'P';
EXEC #TransferHelperObjects 'CheckStageAndPiplineIntegrity', 'P';
EXEC #TransferHelperObjects 'AddPipelineDependant', 'P';
EXEC #TransferHelperObjects 'AddServicePrincipalWrapper', 'P';
EXEC #TransferHelperObjects 'AddServicePrincipalUrls', 'P';
EXEC #TransferHelperObjects 'AddServicePrincipal', 'P';
EXEC #TransferHelperObjects 'DeleteServicePrincipal', 'P';
EXEC #TransferHelperObjects 'CheckForValidURL', 'FN';
EXEC #TransferHelperObjects 'PipelineDependencyChains', 'V';
IF OBJECT_ID(N'tempdb..#TransferReportingObjects') IS NOT NULL DROP PROCEDURE #TransferReportingObjects;
GO

CREATE PROCEDURE #TransferReportingObjects
	(
	@ObjectName NVARCHAR(128),
	@ObjectType CHAR(2)
	)
AS
BEGIN
	IF EXISTS
		(
		SELECT
			*
		FROM
			sys.objects o
			INNER JOIN sys.schemas s
				ON o.[schema_id] = s.[schema_id]
		WHERE
			o.[Name] = @ObjectName
			AND s.[name] = 'procfwk'
			AND o.[type] = @ObjectType
		)
		BEGIN
			PRINT 'Transferring: ' + @ObjectName;
			EXEC('ALTER SCHEMA [procfwkHelpers] TRANSFER [procfwk].[' + @ObjectName + '];')
		END;
END;
GO

EXEC #TransferReportingObjects 'PipelineDependencyChains', 'V';

GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
